/**
  * @namespace hobs
  */
 window.hobs = window.hobs || {};

 (function (hobs) {
    "use strict";

    hobs.namespace = 'hobs';

    var _DEFAULT_CONFIG = {
        debug: false,
        context_path: "",
        action_timeout: 20000,
        poll_interval: 250,
        global_timeout: 30000,
        navigation_timeout: 3600000,
        default_win_options: "width=1220, height=900, top=30, left=30",
        pacing_delay: 0,
        ie11_maxretries: 100,
        global_maxretries_on_failed: 0
    };

    /**
     * @namespace config
     * @memberof hobs
     *
     * @property {boolean}  debug=false                     - Enable/Disable Hobbes.js debug messages in web console. See {@link hobs.log}
     * @property {string}   context_path=""                 - URL prefix used during navigation. See {@link hobs.navigate}
     * @property {int}      action_timeout=20000            - Test action default timeout in ms.
     * @property {int}      poll_interval=250               - Default Polling interval for checking actions (in ms.). See {@link hobs.Chaining.PollCheckStep}
     * @property {int}      global_timeout=30000            - Default timeout used for {@link hobs.actions.core.execFct} execution
     * @property {int}      navigation_timeout=3600000      - Default timeout for navigation actions (in ms.). See {@link hobs.navigate}
     * @property {string}   default_win_options="width=1220,height=900,top=30,left=30" - Default options used when Hobbes.js opens a new window
     *                                                                                      (see {@link hobs.actions.core.openWindow} and {@link hobs.TestSuite} *
     *                                                                                       execInNewWindow option)
     * @property {int}      pacing_delay=0                  - Default pacing delay (in ms.) for testcase actions. If > 0, it will add a delay before each test actions of each testcase
     * @property {int}      global_maxretries_on_failed=0   - Number of time to re-execute a test if it fails
     *
     *
     * @example <caption>hobs.config.pacing_delay - </caption>
     *
     * // Set pacing delay to 1/2s. (500ms)
     * hobs.config.pacing_delay = 500;
     *
     * new hobs.TestCase('tc#1')
     *  // 500ms delay then,
     *  .navigateTo('/shop/home.html')
     *  // 500ms delay then,
     *  .click('.cart-button')
     *  // 500ms delay then,
     *  .asserts.location('/shop/cart.html');
     *
     * // Disable pacing delay
     * hobs.config.pacing_delay = 0;
     **/
    hobs.config = $.extend({}, _DEFAULT_CONFIG);



    hobs.EXEC_PHASE_BEFORE = 'execPhaseBefore';
    hobs.EXEC_PHASE_AFTER = 'execPhaseAfter';



    /**
     * Events
     **/

    /**
     * Navigation event.
     *
     * @event hobs#CONTEXT_NAVIGATION_LOAD
     * @see {@link hobs.navigate}
     */
    hobs.CONTEXT_NAVIGATION_LOAD = 'contextNavigationLoad';

    /**
     * Navigation error event.
     *
     * @event hobs#CONTEXT_NAVIGATION_LOAD_ERROR
     * @property {Object} xhr XML Http Request object
     * @see {@link hobs.navigate}
     */
    hobs.CONTEXT_NAVIGATION_LOAD_ERROR = 'contextNavigationLoadError';

    hobs.RUN_STARTED = 'runStarted';
    hobs.RUN_FINISHED = 'runFinished';
    hobs.TESTSUITE_STARTED = 'testsuiteStarted';
    hobs.TESTSUITE_FINISHED = 'testsuiteFinished';
    hobs.TESTCASE_STARTED = 'testcaseStarted';
    hobs.TESTCASE_FINISHED = 'testcaseFinished';
    hobs.TESTCASE_FAILED = 'testcaseFailed';

    /**
     * @typedef {*} HobbesDOMElement
     *
     * A representation of a DOM element to interact with
     *
     * It can be:
     * * a string evaluated as a jQuery string selector (it can then be evaluated using {@link hobs.find})
     * * a DOM element (ex. hobs.context().document.getElementById('my-div-id'), hobs.find('.my-div').get(0))
     * * a jQuery object (hobs.find('.my-div'))
     * * a function that returns one of the 3 above type (ex. function() { return hobs.find('.my-div'); })
     *
     * _*REMARK:*_ Hobbes.js always refer to a test context, see {@link hobs.context}
     */

    /**
     * @typedef {object} TestStepOptions
     *
     * @property {*}             [before]        Element(s) to execute before the teststep. It can be :
     * * a Number (representing a wait delay in ms.)
     * * a function to execute
     * * a test element (hobs.TestCase)
     * * an array containing these 3 types.
     * @property {*}             [after]         Element(s) to execute after the teststep. It can be :
     * * a Number (representing a wait delay in ms.)
     * * a function to execute
     * * a test element (hobs.TestCase)
     * * an array containing these 3 types.
     * @property {int}           [delay]         Delay (in ms.) applied before TestCase execution
     * @property {int}           [delayBefore]   Delay (in ms.) applied before TestCase execution
     * @property {int}           [delayAfter]    Delay (in ms.) applied after TestCase execution
     * @property {hobs.TestCase} [execBefore]    Test case executed before TestCase execution
     * @property {hobs.TestCase} [execAfter]     Test case executed after TestCase execution
     * @property {object}        [params]        Defines/Overrides values of dynamic parameters (see {@link hobs.param}) that will be passed to the TestCase
     */

    /**
     * @typedef {TestStepOptions} TestSuiteOptions
     * @augments TestStepOptions
     *
     * @property {string}   [path]                  Relative path to the javascript file defining the TestSuite on the web server
     * @property {boolean}  [execInNewWindow=false] If set to true, the testsuite will be executed in a newly created window (and not in the default test context)
     * @property {boolean}  [register=true]         Control registration of the TestSuite on hobs. By default, only registered TestSuites will be added to the testrunner UI.
     **/

    /**
     * @typedef {TestStepOptions} TestActionOptions
     * @augments TestStepOptions
     *
     * @property {int} [timeout=[hobs.config.action_timeout]{@link hobs.config}] Maximum execution time of the test action (in ms.).
     *                           If timeout is reach, the test action is marked `failed`
     **/

})(window.hobs);


;

(function(window, hobs, $) {
    "use strict";

    /**
     * @namespace
     * @desc Hobbes.js utilities
     *
     * @memberof hobs
     **/
    hobs.utils = {};



    // JQuery empty object mock
    hobs.utils.ZERO_LENGTH_OBJECT = {length: 0};



    function pad(str, max) {
        str = str.toString();
        return str.length < max ? pad(" " + str, max) : str;
    }

    hobs.utils.pad = pad;



    hobs.utils.getCSSNumber = function(val) {
        return parseFloat(val, 10);
    };

    hobs.utils.highlightElement = function(selector, color, actionText, options) {
        var c = color || 'red',
            _options = options || {},
            type = _options.type || 'DOM_EL_BOX',
            actDiv = $('<div class="highlightDiv"></div>');

        // Highlight box around specific interacted DOM Element
        if (type === 'DOM_EL_BOX') {
            var top = $(hobs.context().loadEl).offset() ? $(hobs.context().loadEl).offset().top : 0;
            var left = $(hobs.context().loadEl).offset() ? $(hobs.context().loadEl).offset().left : 0;

            actDiv.css('position', 'absolute')
                .css('border-width', '5px')
                .css('border-style', 'solid')
                .css('border-color', c)
                .css('top', top + hobs.find(selector).offset().top - 5)
                .css('left', left + hobs.find(selector).offset().left - 5)
                .css('width', hobs.utils.getCSSNumber(hobs.find(selector).css('width')))
                .css('height', hobs.utils.getCSSNumber(hobs.find(selector).css('height')))
                .css('z-index', 9000);

            if (actionText) {
                var actText = '<span style="font-family:Verdana;position:absolute;background-color:' + c + ';padding:5px 5px 5px 5px;top:-25px;left:-5px;font-size:.6em;color:white;">' + actionText.toUpperCase() + '</span>';
                actDiv.append(actText);
            }

            $('body').append(actDiv);
        }
        // Highlight box in the center of the test context window
        // For actions such as assertions or code execution or keyboard shortcut...
        else if (type === 'CENTER_BOX') {
            var offset = $(hobs.context().loadEl).offset() || {top: 0, left: 0};

            actDiv.css('position', 'absolute')
                .css('border-width', '5px')
                .css('border-style', 'solid')
                .css('border-color', c)
                .css('top', (offset.top + ($(hobs.context().loadEl).height()/2)))
                .css('left', (offset.left + ($(hobs.context().loadEl).width()/2)))
                .css('z-index', 9000);

            if (actionText) {
                var actTextCentered = '<span style="font-family:Verdana;background-color:' + c + ';font-size:1.6em;color:white;">' + actionText.toUpperCase() + '</span>';
                actDiv.append(actTextCentered);

            }

            $('body').append(actDiv);

            actDiv.css('margin-left', -(actDiv.width()/2));
            actDiv.css('margin-top', -(actDiv.height()/2));
        }

        return actDiv;
    };

    hobs.utils.getIdFromString = function(s) {
        if ($.type(s) !== 'string') {
            return null;
        }

        return s.replace(/[^\w\s]/gi, '').replace(/[\s]/gi, '_').toLowerCase();
    };

    // hobs.utils.getCurrentFilePath = function() {
    //     var scripts = document.getElementsByTagName("script"),
    //         currentFilePath = scripts[scripts.length-1];
    //
    //     hobs.log('Current File Path: ' + $(currentFilePath).attr("src"));
    //
    //     return $(currentFilePath).attr("src");
    // };

    hobs.utils.objectFindByKey = function(array, key, value) {
        if ($.isArray(array)) {
            for (var i = 0; i < array.length; i++) {
                if ($.isFunction(array[i][key]) && array[i][key]() === value) {
                    return array[i];
                }
                else if (key in array[i] && array[i][key] === value) {
                    return array[i];
                }
            }
        }
        return null;
    };

    hobs.utils.extendNamespace = function( ns, ns_string ) {
        var parts = ns_string.split('.'),
            parent = ns,
            pl, i;
        /*if (parts[0] == 'myApp') {
            parts = parts.slice(1);
        }*/
        pl = parts.length;
        for (i = 0; i < pl; i++) {
            //create a property if it doesnt exist
            if (typeof parent[parts[i]] === 'undefined') {
                parent[parts[i]] = {};
            }
            parent = parent[parts[i]];
        }
        return parent;
    };

    hobs.utils.extend = function(obj, properties) {
        if (!properties) {
            return;
        }

        $.each( properties, function( key, value ) {
            obj[key] = value;
        });
    };

    hobs.utils.definePrototype = function(obj, prototypeFn, properties) {
        obj.prototype = new prototypeFn();
        obj.prototype.constructor = obj;

        hobs.utils.extend(obj.prototype, properties);
    };

    /**
     * Safely executes a function (function execution wrapped in a try catch block)
     *
     * @param {function} fn the function to execute
     * @param {*} [context=this] the execution context of the function
     * @param {Array} [params] The array of parameters to pass to the function
     *
     * @returns {Promise} A promise
     *
     * @memberof hobs.utils
     **/
    hobs.utils.safeApplyFn = function(fn, context, params) {
        context = context || this;

        var dfr = $.Deferred();

        try {
            var fnReturn = fn.apply(context, params);
            dfr.resolve(fnReturn, dfr);
        }
        catch(err) {
            hobs.log(err.stack);
            dfr.reject(err, dfr);
        }

        return dfr.promise();
    };



    /**
     * https://gist.github.com/7265412
     * Get stack of DOM elements present at x,y coordinates
     *
     * @param {int} x the x coordinate, in pixels
     * @param {int} y the y coordinate, in pixels
     * @param {DOMElement} [document=hobs.context().document] the document in which elements are looking for
     *
     * @returns {Array.<DOMElement>} An array of all the DOM elements found at given coordinates
     *
     * @memberof hobs.utils
     **/
    hobs.utils.elementsFromPoint = function(x, y, document) {
        var elements = [],
            previousPointerEvents = [],
            doc = document || hobs.context().document,
            current, i, d;

        // get all elements via elementFromPoint, and remove them from hit-testing in order
        while ((current = doc.elementFromPoint(x,y)) && elements.indexOf(current) === -1 && current !== null) {

            // push the element and its current style
            elements.push(current);
            previousPointerEvents.push({
                    value: current.style.getPropertyValue('pointer-events'),
                    priority: current.style.getPropertyPriority('pointer-events')
                });

                // add "pointer-events: none", to get to the underlying element
            current.style.setProperty('pointer-events', 'none', 'important');
        }

        // restore the previous pointer-events values
        /*jshint -W084 */
        for(i = previousPointerEvents.length; d=previousPointerEvents[--i]; ) {
            elements[i].style.setProperty('pointer-events', d.value?d.value:'', d.priority);
        }

        // return our results
        return elements;
    };



    hobs.utils.deepObjectSearch = function(obj, key, value) {
        if (value === undefined) {
            return null;
        }

        var result = null;

        for (var k in obj) {
            if(k in obj) {
                var candidate = obj[k];

                if (candidate !== null && typeof candidate === 'object' && !(obj[k] instanceof RegExp)) {
                    result = hobs.utils.deepObjectSearch(candidate, key, value);

                    if (result) {
                        break;
                    }
                }
                else {
                    if (obj[k] instanceof RegExp) {
                        var m = obj[k].exec(value);
                        if (m !== null && m.length > 0) {
                            hobs.log("Object.searchIn(...) found: " + k + " /// " + obj[k]);
                            result = obj;

                            break;
                        }
                    }
                    else {
                        if (k === key && value === obj[k]) {
                            hobs.log("Object.searchIn(...) found: " + k + " /// " + obj[k]);
                            result = obj;

                            break;
                        }
                    }
                }
            }
        }

        return result;
    };

    hobs.utils.deepKeySearchInObject = function(obj, key) {
        var result = false,
            searchedOn = obj;

        if (key in searchedOn) {
            result = searchedOn;
        } else {
            $.each(searchedOn, function(k, v) {
                var candidate = v;

                if ($.isPlainObject(candidate)) {
                    result = hobs.utils.deepKeySearchInObject(candidate, key);

                    if (result) {
                        return false;
                    }
                }
                else {
                    if (k === key) {
                        result = this;
                        return false;
                    }
                }
            });
        }

        return result;
    };

    /**
     * Remove all steps (TestCase and TestSuite) from the given TestSuite that are not matching the given metadata object
     *
     * @param {hobs.TestSuite} testsuite to be filtered
     * @param {object} withMetadata the object containing the metadata properties and values that should match
     *
     * @returns void, nothing is returned as the given testsuite is directly modified.
     *
     * @memberof hobs.utils
     **/
    hobs.utils.metadataFilter = function(testsuite, withMetadata) {
        // define a recursive function to traverse TestSuite's TestCases
        function filterTestSuite(_testsuite, opts) {
            // filter and only keep testcases that match the filterMetadata
            var _steps = _testsuite.getTestCases();
            for (var i = 0; i < _steps.length;) {
                var step = _steps[i];
                var mergedOptions = $.extend({}, opts);
                var stepOptions = $.extend(mergedOptions, step.options());
                var stepRemoved = false;
                if (hobs.TestCase.prototype.isPrototypeOf(step)) {
                    for (var k in withMetadata) {
                        if (withMetadata[k].type === "include" && (stepOptions.metadata === undefined || stepOptions.metadata[k] === undefined || withMetadata[k].value !== stepOptions.metadata[k])) {
                            _steps.splice(i, 1);
                            stepRemoved = true;
                            break;
                        } else if (withMetadata[k].type === "exclude" && (stepOptions.metadata !== undefined && stepOptions.metadata[k] !== undefined && withMetadata[k].value === stepOptions.metadata[k])) {
                            _steps.splice(i, 1);
                            stepRemoved = true;
                            break;
                        } else {
                            // unknown type
                        }
                    }
                }
                if(hobs.TestSuite.prototype.isPrototypeOf(step)) {
                    // recursively apply the filter to inner TestSuite
                    filterTestSuite(step, stepOptions);
                    if (step.getTestCases().length === 0) {
                        // no TestCase contained in the TestSuite so no need to keep it.
                        _steps.splice(i, 1);
                        stepRemoved = true;
                    }
                }
                if (!stepRemoved) {
                    // can increase to next teststep
                    i++;
                }
            }
        }
        if (testsuite !== null) {
            filterTestSuite(testsuite, testsuite.options());
        }
    };

    /**
     * Remove all steps (TestCase and TestSuite) from the given TestSuite that are not matching the given paths object
     *
     * @param {hobs.TestSuite} testsuite to be filtered
     * @param {object} withPaths the object containing the path value and a type include/exclude
     *
     * @returns void, nothing is returned as the given testsuite is directly modified.
     *
     * @memberof hobs.utils
     **/
    hobs.utils.pathFilter = function(testsuite, withPaths) {
        function typeRank(a) {
            return a === 'exclude' ? 1:-1;
        }
        function sortType(a,b) {
            var result = 0;
            if (a.type === b.type) {
                // compare path
                if (a.path > b.path) {
                    result = 1;
                } else {
                    result = -1;
                }
            } else {
                result = typeRank(a.type) - typeRank(b.type);
            }
            return result;
        }
        // sort to have include rules on top order by path
        withPaths.sort(sortType);
        // define a recursive function to traverse TestSuite's TestCases
        function filterTestSuite(_testsuite, path) {
            // filter and only keep testcases that match the filterMetadata
            var _steps = _testsuite.getTestCases();            
            for (var i = 0; i < _steps.length; i++) {
                if (!_steps[i]) {
                    break;
                }
                var step = _steps[i];
                var curPath = path + "/" + step.id;
                var stepRemoved = true;
                if (hobs.TestCase.prototype.isPrototypeOf(step)) {
                    for (var k = 0; k < withPaths.length; k++) {
                        if (withPaths[k].type === "include" && curPath.indexOf(withPaths[k].path) === 0) {
                            // dont remove if include mode and path is a substring of curPath
                            stepRemoved = false;
                        } else if (withPaths[k].type === "exclude" && curPath.indexOf(withPaths[k].path) === 0) {
                            stepRemoved = true;
                            break; // stop as soon as an exclude rule match
                        }
                    }
                    if (stepRemoved) {
                        _steps.splice(i, 1);
                        i--;
                    }
                }
                if(hobs.TestSuite.prototype.isPrototypeOf(step)) {
                    // recursively apply the filter to inner TestSuite
                    filterTestSuite(step, curPath);
                    if (step.getTestCases().length === 0) {
                        // no TestCase contained in the TestSuite so no need to keep it.
                        _steps.splice(i, 1);
                        i--;
                    }
                }
            }
        }
        filterTestSuite(testsuite, "/"+testsuite.id);
    };

    /**
     * List the computed paths for the testsuites and inner testcases/testsuites
     *
     * @param {array} allSteps the array of steps to be filtered
     * 
     * @returns {array} the array of string containing the computed paths.
     *
     * @memberof hobs.utils
     **/
    hobs.utils.listPaths = function(allSteps) {
        var list = [];
        // define a recursive function to traverse TestSuite's TestCases
        function filterTestSuite(_testsuite, path) {
            // filter and only keep testcases that match the filterMetadata
            var _steps = _testsuite.getTestCases();            
            for (var i = 0; i < _steps.length; i++) {
                var step = _steps[i];
                var curPath = path + "/" + step.id;
                if (hobs.TestCase.prototype.isPrototypeOf(step)) {
                    list.push(curPath);
                }
                if(hobs.TestSuite.prototype.isPrototypeOf(step)) {
                    // recursively apply the filter to inner TestSuite
                    filterTestSuite(step, curPath);
                }
            }
        }
        for (var k=0; k < allSteps.length; k++) {
            filterTestSuite(allSteps[k], "/"+allSteps[k].id);
        }
        return list;
    };

    /**
     * Remove all steps (TestCase and TestSuite) that appear before the targeted TestCase path provided as array of names.
     * if the path is not found , then allSteps should be cleared.
     * if the path is found, all the remaining steps to execute should be still part of the allSteps.
     *
     * @param {array} allSteps the array of steps to be filtered
     * @param {array} resumePath the array of name representing the path (i.e path = /a/b/c = [ "a", "b", "c"] = "c" as testcase in testsuite "b", which is itself in testsuite "a"
     *
     * @returns {boolean} true if the path was found and it removed the steps that are not relevant to execute.
     *
     * @memberof hobs.utils
     **/
    hobs.utils.resumeFilter = function(allSteps, resumePath) {

        var targetPath = resumePath;

        // define a recursive function to traverse TestSuite's TestCases
        function resumeFilter(steps, path) {
            // filter and only keep testcases that match the filterMetadata
            for (var i = 0; i < steps.length;) {
                var testStep = steps[i];
                var curPath = path + "/" + testStep.id;
                if (targetPath.indexOf(curPath) === 0) {
                    if (targetPath === curPath) {
                        // found the target testcase , remove that last one and exit
                        steps.splice(i, 1);
                        return true;
                    } else if(hobs.TestSuite.prototype.isPrototypeOf(testStep)) {
                        // recursively apply the filter to inner TestSuite
                        if (resumeFilter(testStep.getTestCases(), curPath)) {
                            return true;
                        } else {
                            steps.splice(i, 1);
                        }
                    }
                } else {
                    // not matching sub path so removing it
                    steps.splice(i, 1);
                }
            }
            return false;
        }

        resumeFilter(allSteps, "");

    };

    /*
     * Generate random strings to be used to create values using alpha and digits (A-Za-z0-9)
     * @param {integer} len the length of the generated string
     *
     * @returns {string} a random string (alpha + digit) with the length defined as parameter.
     *
     * @memberof hobs.utils
     */
    hobs.utils.getRandomString = function(len) {
        var text= '', l = len || 5, allowedChar = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        for(var i=0; i < l; i++)
        {
            text += allowedChar.charAt(Math.floor(Math.random() * allowedChar.length));
        }
        return text;
    };

})(window, window.hobs, $);


;

(function(window, hobs, $) {
    "use strict";



    /**
     * @namespace
     *
     * @desc DOM related utils
     **/
    hobs.utils.dom = {};

    function isCssVisible(elem) {
        var $elem = $(elem);
        return !(
            $elem.css('display') === 'none' ||
            $elem.css('visibility') === 'hidden' ||
            $elem.css('opacity') === "0"
        );
    }

    /**
     * 
     * @param {*} elem Object DOM element on which this operation is performed 
     * @param {*} pseudoElt String pseudo element, accepted values are "before" or "after"
     * @returns length of the 'content' property of the pseudo element, or -1 if not found or unknown pseudoElt.
     */
    function pseudoElementContentLength(elem, pseudoElt) {
        var length = -1;
        if (pseudoElt === 'before' || pseudoElt === 'after') {
            var win = hobs.context().window; 
            if (win) {
                var computedStyle = win.getComputedStyle(elem,':'+pseudoElt);
                if (computedStyle) {
                    length = computedStyle.getPropertyValue('content').length;
                }
            }
        }
        return length;
    }

    function elementIsVisible(elem){
        var $elem = ($.type(elem) === 'string') ? hobs.find(elem).eq(0) : $(elem).eq(0),
            parentVisible = true;

        if ($elem.length === 0) {
            return false;
        }

        // Check if elem is hidden through css as this is not very costly:
        if (!isCssVisible($elem)) {
            return false;
        }

        // // Check elem size. width/height == 0 means not visible
        // if ($elem.outerWidth() === 0 || $elem.outerHeight() === 0) {
        //     return false;
        // }

        // Check background transparency for SPAN/DIV
        if (($.inArray($elem.prop('tagName'), ['DIV', 'SPAN'])) >= 0 &&
            pseudoElementContentLength($elem.get(0),'before') <= 0 &&
            pseudoElementContentLength($elem.get(0),'after') <= 0 &&
            ($.inArray($elem.css('background'), ['', 'rgb(0, 0, 0)', 'rgba(0, 0, 0, 0)'])) >= 0 &&
            ($.inArray($elem.css('background-color'), ['', 'rgb(0, 0, 0)', 'rgba(0, 0, 0, 0)'])) >= 0 &&
            $elem.children().length === 0
        ) {
            return false;
        }

        // check element's parent(s) CSS visibility
        $elem.parents().each(function(idx, item) {
            if (!isCssVisible(item)) {
                parentVisible = false;
                return false;
            }
        });
        if (!parentVisible) {
            return false;
        }

        // //Now check for elements positioned on top:
        // var elemBox = $elem.get(0).getBoundingClientRect(),
        //     topLeftDomEl = hobs.context().document.elementFromPoint(elemBox.left, elemBox.top),
        //     // bottomRightDomEl = hobs.context().document.elementFromPoint((elemBox.left + elemBox.width - 2) , (elemBox.top + elemBox.height - 2)),
        //     topLeftBoxOverlayed = false,
        //     bottomRightBoxOverlayed = true;
        //
        // // top left corner of the element is not the top element in the dom and its "overlayer" is visible
        // if (topLeftDomEl !== $elem.get(0)) {
        //     if(elementIsVisible(topLeftDomEl)) {
        //         topLeftBoxOverlayed = true;
        //     }
        // }
        //
        // // bottom right corner of the element is not the top element in the dom and its "overlayer" is visible
        // if (bottomRightDomEl !== $elem.get(0)) {
        //     if(isVisible(bottomRightDomEl)) {
        //         bottomRightBoxOverlayed = true;
        //     }
        // }
        //
        // if (topLeftBoxOverlayed && bottomRightBoxOverlayed) {
        //     return false;
        // }

        // Is in viewport
        return Array.prototype.reduce.call(
            $elem.map(
                function() {
                    if (!hobs.context().window) {
                        return false;
                    }

                    var rect = this.getBoundingClientRect(),
                        wW = $(hobs.context().window).width(),
                        wH = $(hobs.context().window).height();
                    return Math.ceil(rect.left) >= 0
                        || Math.floor(rect.right) <= wW
                        || Math.ceil(rect.top) >= 0
                        || Math.floor(rect.bottom) <= wH;
                }
            ),
            function(allVisible, thisVisible) {
                return allVisible && thisVisible;
            },
            true
        );

    }

    /**
     * @function elementIsVisible
     *
     * @desc Checks *real* visibility of a DOM element.
     *
     * A DOM element _elem_ is considered visible if all the following criterias are true:
     * * _elem_ exists in the DOM
     * * _elem_ does not have a CSS property making it invisible (display, visibility, opacity)
     * * _elem_ does not have an invisible parentVisible
     * * _elem_ is in the viewport
     * * _elem_ top left corner point is not overlayed by another DOM element
     *
     * @param {string|DOMElement} elem The element to check (if string, considered as a jQuery selector that will be searched using {@link hobs.find})
     *
     * @returns boolean true if the element is visible
     * To be considered visible, elem
     *
     * @memberof hobs.utils.dom
     **/
    hobs.utils.dom.elementIsVisible = elementIsVisible;

    /**
     * Derived from https://gist.github.com/iimos/e9e96f036a3c174d0bf4
     **/
    function xpath(el, doc) {
        doc = doc || document;

        if (typeof el === "string") {
            return doc.evaluate(el, doc, null, 0, null);
        }

        if ($.isWindow(el)) {
            return 'window';
        }

        if (el && el.nodeType === 9) {
            return 'document';
        }

        if (!el || el.nodeType !== 1) {
            return '';
        }

        if (el.id) {
            return "//*[@id='" + el.id + "']";
        }

        var sames = [].filter.call(el.parentNode.children, function (x) { return x.tagName === el.tagName; });

        return xpath(el.parentNode) + '/' + el.tagName.toLowerCase() + (sames.length > 1 ? '['+([].indexOf.call(sames, el)+1)+']' : '');
    }

    /**
     * @function getXPath
     *
     * @desc Get XPath string representation of a DOM element.
     *
     * @param {string|DOMElement} el The DOM element to evaluate
     *
     * @returns string XPath string representation of the given element
     *
     * @memberof hobs.utils.dom
     **/
    hobs.utils.dom.getXPath = xpath;



    function getJQElFromSelector(selector, opts) {
        opts = opts || {};

        try {
            // String. Evaluate as a jQuery string selector
            if ($.type(selector) === 'string') {
                var sel_dyn = hobs.handleDynParameters(selector, opts);
                return hobs.find(sel_dyn, opts.context);
            }
            // jQuery object
            else if (selector instanceof $ && selector.context === hobs.context().document) {
                return selector;
            }
            // DOM Element
            else if (selector && selector.nodeType && selector.nodeType === 1 && selector.ownerDocument === hobs.context().document) {
                return hobs.find(selector);
            }
            // Function. Execute it and pass the result to the checking function
            else if ($.isFunction(selector)) {
                return getJQElFromSelector(selector(), opts);
            }
            // Unsupported selector type, return empty jQuery object
            else {
                return hobs.utils.ZERO_LENGTH_OBJECT;
            }
        }
        catch (err) {
            hobs.log(err.stack);
            return hobs.utils.ZERO_LENGTH_OBJECT;
        }
    }



    hobs.utils.dom.getJQElFromSelector = getJQElFromSelector;

    hobs.utils.dom.getElementCenter = function(el) {
        var $el = getJQElFromSelector(el);

        var offset = $el.offset();
    	var width = $el.width();
    	var height = $el.height();

    	var centerX = offset.left + width / 2;
    	var centerY = offset.top + height / 2;

        return {x: centerX, y: centerY};
    };



})(window, window.hobs, $);


;

(function(window, hobs, $) {
    "use strict";

    /**
     * @namespace
     *
     * @desc HApi related utils
     **/
    hobs.utils.hapi = {};

    function elements(itemtype) {
        return $(hobs.context().document).items(itemtype);
    }

    /**
     * @function elements
     *
     * @desc Return all HApi elements on a page. Can optionally be filtered by their type.
     *
     * @param {String} itemtype The type of HApi elements to return. Should be the path to the model definition or parts of it, e.g. the suffix. A call with an empty itemtype returns all HApi elements on a page.
     *
     * @returns {@link http://api.jquery.com/Types/#jQuery|jQuery} The matching HApi elements as jQuery objects.
     *
     * @api public
     *
     * @memberof hobs.utils.hapi
     */
    hobs.utils.hapi.elements = elements;

})(window, window.hobs, $);


;

(function(window, hobs, $) {
    "use strict";



    /*
     * @class CustomEvent
     * @classdesc CustomEvent Polyfill (IE9/10/11)
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent}
     * @memberof window
     *
     * @param {String} event Name of the custom event
     * @param {Object} params Details object of the event
     */
    try {
        new CustomEvent("test");
    } catch(e) {
        var custEvt = function(event, params) {
            var evt;
            params = params || {
                bubbles: false,
                cancelable: false,
                detail: undefined
            };

            evt = hobs.context().document.createEvent("CustomEvent");
            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
            return evt;
        };

        custEvt.prototype = window.Event.prototype;
        window.CustomEvent = custEvt; // expose definition to window
    }

    /**
     * Function.prototype.bind Polyfill
     **/
    if (typeof Function.prototype.bind !== 'function') {
        Function.prototype.bind = function bind(obj) {
            var args = Array.prototype.slice.call(arguments, 1),
                self = this,
                fn = function() {
                },
                b = function() {
                    return self.apply(
                        this instanceof fn ? this : (obj || {}), args.concat(
                            Array.prototype.slice.call(arguments)
                        )
                    );
                };
            fn.prototype = this.prototype || {};
            b.prototype = new fn();
            return b;
        };
    }

    try {
        window.performance.now();
    }
    catch(e) {
        window.performance = window.performance || {};

        window.performance.now = function() {
            return Date.now();
        };
    }

})(window, window.hobs, $);


;

/**
 * Main namespace
 * @namespace hobs.Chaining
 */
window.hobs.Chaining = {};

(function (hobs, Chaining, $) {

    "use strict";

    /**
     * @property {number} DEFAULT_POLL_INTERVAL - Default ms. interval used in interval like steps
     */
    Chaining.DEFAULT_POLL_INTERVAL = 10;

    /**
     * @memberof hobs.Chaining
     * @type {Object}
     * @property {function} returnFalse A function that return false
     * @property {function} forceFail A function to use in a [Step]{@link hobs.chaining.Step} to force it to fail
     * @property {function} forcePass A function to use in a [Step]{@link hobs.chaining.Step} to force it to pass
     */
    Chaining.defaultActions = {

        /**
         * Generic function always returning false
         **/
        returnFalse: function () {
            return false;
        },

        /**
         * Generic function always failing
         **/
        forceFail: function (opts, dfr) {
            hobs.log('%s Default Exec Function Used! Resolves step to failed', this.LOG_PREFIX);
            this.done(Chaining.Step.STATE_FAILED);
        },

        /**
         * Generic function always failing
         **/
        forcePass: function (opts, dfr) {
            hobs.log('%s Default Exec Function Used! Resolves step to passed', this.LOG_PREFIX);
            this.done(Chaining.Step.STATE_PASSED);
        }

    };

})(window.hobs, window.hobs.Chaining, window.$);


;

(function (hobs, Chaining, $) {
    "use strict";

    /**
     * A Step object to control the execution of a function via a Promise
     *
     * @class
     * @alias hobs.Chaining.Step
     */
    Chaining.Step = function(fct, options) {
        this._fct = fct || Chaining.defaultActions.forceFail;
        this._options = options || {};
        this.dfr_ = null;
    };

    /**
     * @ignore
     */
    Chaining.Step.prototype.constructor = Chaining.Step;


    /**
     * @constant hobs.Chaining.Step.STATE_CANCELED
     * @desc **FINAL STATE** The step got cancelled before the end of its execution
     **/
    Chaining.Step.STATE_CANCELED = 'canceled';

    /**
     * @constant hobs.Chaining.Step.STATE_FAILED
     * @desc **FINALE STATE** The step failed
     **/
    Chaining.Step.STATE_FAILED = 'failed';

    /**
     * @constant hobs.Chaining.Step.STATE_PASSED
     * @desc **FINAL STATE** The step passed
     **/
    Chaining.Step.STATE_PASSED = 'passed';

    /**
     * @constant hobs.Chaining.Step.STATE_PAUSED
     * @desc State of a {@link hobs.Chaining.Step} currently paused
     **/
    Chaining.Step.STATE_PAUSED = 'paused';

    /**
     * @constant hobs.Chaining.Step.STATE_RESUMED
     * @desc State of a Step having been resumed after getting paused
     **/
    Chaining.Step.STATE_RESUMED = 'resumed';

    /**
     * @constant hobs.Chaining.Step.STATE_RUNNING
     * @desc State of a Step currently being executed
     **/
    Chaining.Step.STATE_RUNNING = 'running';

    /**
     * @constant hobs.Chaining.Step.STATE_STOPPED
     * @desc Default state of a Step instance. Not yet executed
     * @default
     **/
    Chaining.Step.STATE_STOPPED = 'stopped';

    /**
     * @constant hobs.Chaining.Step.STATE_COMPLETED
     * @desc State of a Step which function got completed (not final state)
     **/
    Chaining.Step.STATE_COMPLETED = 'completed';


    Chaining.Step.prototype._state = Chaining.Step.STATE_STOPPED;
    Chaining.Step.prototype._pendingState = null;


    /**
     * Returns the current state of the step
     *
     * @function hobs.Chaining.Step#state
     * @return {String}
     */
    Chaining.Step.prototype.state = function () {
        return this._state;
    };


    /**
     * Get/set options of the step
     *
     * @function hobs.Chaining.Step#options
     *
     * @param {string} name  The name of the option property
     * @param {*}      value The value to set the option property to
     *
     * @example
     * // Init Step with options
     * var step = new hobs.Chaining.Step(null, {prop1: 'string', prop2: 12});
     *
     * // Get all the options as an Object
     * step.options(); // => {prop1: 'string', prop2: 12}
     *
     * // Get the value of a specific option property
     * step.options('prop1'); // => 'string'
     * step.options('prop2'); // => 12
     *
     * // Set the value of a specific option property
     * step.options('prop1', true);
     * step.options('prop2', 123);
     * step.options(); // => {prop1: true, prop2: 123}
     **/
    Chaining.Step.prototype.options = function (name, value) {
        if (name === undefined && value === undefined) {
            return this._options;
        }
        else if ($.type(name) === 'string' && value === undefined) {
            return this._options[name];
        }
        else {
            this._options[name] = value;
        }
    };

    /**
     * @ignore
     * @returns {object} The deferred object of the step
     **/
    Chaining.Step.prototype.dfr = function () {
        return this.dfr_;
    };

    /**
     * Executes the step. It consists of executing the function passed to the
     * constructor.
     *
     * @function hobs.Chaining.Step#exec
     *
     * @param {Object} [options] - Extra properties, extending the ones set at the instantiation of the step
     *                             and passed, as first argument, to the step function.
     *
     * @returns {Object} A promise
     **/
    Chaining.Step.prototype.exec = function (options) {
        var opt = $.extend({}, this._options, options),
            d = initdfr_.call(this);

        setState.call(this, Chaining.Step.STATE_RUNNING);

        // Execute step after delay
        this._fct(opt, this.dfr());

        return d.promise();
    };

    /**
     * Cancels step execution
     *
     * @function hobs.Chaining.Step#cancel
     **/
    Chaining.Step.prototype.cancel = function () {
        setState.call(this, Chaining.Step.STATE_CANCELED);
    };

    /**
     * Completes step execution
     *
     * @function hobs.Chaining.Step#done
     *
     * @param {string} state  The final state of the step
     * @param {object} result The result of the step execution
     **/
    Chaining.Step.prototype.done = function (state, result) {
        if (this.state() === Chaining.Step.STATE_PAUSED) {
            this._pendingState = state;
        } else if (this.dfr_) {
            this.dfr_.notify({type: Chaining.Step.STATE_COMPLETED, state: state, result: (result || {result: state})});
        }
    };

    /**
     * Pauses step execution
     *
     * @function hobs.Chaining.Step#pause
     **/
    Chaining.Step.prototype.pause = function () {
        if (this.state() === Chaining.Step.STATE_RUNNING || this.state() === Chaining.Step.STATE_RESUMED) {
            setState.call(this, Chaining.Step.STATE_PAUSED);
        } else {
            $.error('Step not running, cannot pause it!');
        }
    };

    /**
     * Resumes execution of a paused step
     *
     * @function hobs.Chaining.Step#resume
     *
     * @throws Will throw an error if the step is not paused
     **/
    Chaining.Step.prototype.resume = function () {
        if (this.state() === Chaining.Step.STATE_PAUSED) {
            if (this._pendingState !== null) {
                setState.call(this, this._pendingState);
                this.dfr_.notify({type: Chaining.Step.STATE_COMPLETED, state: this._pendingState, result: this._pendingState});
                this._pendingState = null;
            } else {
                setState.call(this, Chaining.Step.STATE_RESUMED);
            }
        } else {
            $.error('Step not in pause, cannot resume it!');
        }
    };



    /**
     * Initializes the deferred object
     *
     * @ignore
     **/
    function initdfr_() {
        var _step = this;

        _step.dfr_ = $.Deferred();

        function handleResult(result) {
            _step.dfr_ = null;
        }

        function handleNotification(notification) {
            if (notification.type === Chaining.Step.STATE_COMPLETED) {
                setState.call(_step, notification.state);
                _step.dfr_.resolve(notification.result);
            }
            else if (notification.state === Chaining.Step.STATE_CANCELED) {
                _step.done(Chaining.Step.STATE_CANCELED);
            }
        }

        _step.dfr_
            .progress(handleNotification)
            .always(handleResult);

        return _step.dfr_;
    }

    /**
     * Changes state of the step
     *
     * @ignore
     *
     * @param {string} state - The new state of the step
     **/
    function setState(state) {
        this._state = state;
        this.dfr_.notify({type: 'set-state', state: this._state});
    }


})(window.hobs, window.hobs.Chaining, window.$);


;

(function (hobs, Chaining, $) {

    "use strict";



    /**
      @class Chain
      @classdesc A Chain executes a sequence of step like objects
      @extends Chaining.Step
      @param {object} [options] - Extra options passed to the chain to control its execution
      @memberof hobs.Chaining
    */
    Chaining.Chain = function (options) {
        this.steps_ = [];
        this.LOG_PREFIX = this.LOG_PREFIX ? this.LOG_PREFIX + ' ' : ' ';

        var execFct = options !== undefined && options.chainExecFct ? options.chainExecFct : chainExecFct;
        Chaining.Step.call(this, execFct, options);
    };

    /**
     * @property {string} STEP_EXECUTED - Event triggered after each step of the chain gets executed
     * @memberof hobs.Chaining.Chain
     **/
    Chaining.Chain.STEP_EXECUTED = 'stepExecuted';

    /**
     * @property {string} CHAIN_EXECUTED - Event triggered after chain finish execution
     * @memberof hobs.Chaining.Chain
     **/
    Chaining.Chain.CHAIN_EXECUTED = 'chainExecuted';

    Chaining.Chain.prototype = new Chaining.Step();

    // Constructor
    Chaining.Chain.prototype.constructor = Chaining.Chain;

    Chaining.Chain.prototype.currentStep_ = null;

    Chaining.Chain.prototype.currentStep_Idx = -1;

    /**
     * @returns {Chaining.Step} The current step executed in the chain
     **/
    Chaining.Chain.prototype.currentStep = function () {
        return this.currentStep_;
    };

    /**
     * @returns {Chaining.Step[]} The steps contained in the chain
     **/
    Chaining.Chain.prototype.steps = function () {
        return this.steps_;
    };

    /**
     * Get the index in the chain execution of a given step
     *
     * @param {Chaining.Step}
     * @returns {Number} The index of the given step in the chain. Returns null if the step is not in the chain
     **/
    Chaining.Chain.prototype.getStepIndex = function (step) {
        return $(this.steps_).index(step);
    };

    /**
     * @returns {boolean} Returns true if the chain got executed and all the steps have passed. Returns false if any of the step failed
     **/
    Chaining.Chain.prototype.hasPassed = function () {
        var i;

        for (i = 0; i < this.steps_.length; i++) {
            if (this.steps_[i].state() !== Chaining.Step.STATE_PASSED) {
                return false;
            }
        }

        return true;
    };

    /**
     * @returns {string} Returns a string representation of the progress of the chain execution (ex. 2 / 4 - 25%)
     **/
    Chaining.Chain.prototype.getProgress = function () {
        if (this.steps_.length <= 0) {
            return 0;
        }

        var hrStepIdx = this.currentStep_Idx,
            ret = hrStepIdx + ' / ' + this.steps_.length + ' - ' + Math.round(hrStepIdx / (this.steps_.length) * 100) + '%';

        return ret;
    };

    /**
     * Append a step to the chain
     *
     * @param {Chaining.Step} step - The step to add to the chain
     * @returns {Chaining.Chain} Returns itself for chaining purpose
     **/
    Chaining.Chain.prototype.addStep = function (step) {
        this.steps_.push(step);

        return this;
    };

    /**
     * Cancel chain execution
     *
     * @override
     **/
    Chaining.Chain.prototype.cancel = function () {
        var _chain = this;

        function alwaysHandler() {
            Chaining.Step.prototype.cancel.call(_chain);
        }

        this.currentStep().dfr().always(alwaysHandler);

        // Call super.cancel() (Chaining.Step.cancel())
        this.currentStep().cancel();
    };

    /**
     * Chain execution function
     **/
    function chainExecFct(options) {
        var _chain = this,
            stepsToExecute = $.merge([], this.steps_),
            execFct = options !== undefined && options.execStepFct ? options.execStepFct : execStepFct;


        function chainProgressHandler(notification) {
            if (notification.state === Chaining.Step.STATE_PAUSED) {
                _chain.currentStep_.pause();
            } else if (notification.state === Chaining.Step.STATE_RESUMED) {
                _chain.currentStep_.resume();
            }
            //  else if (notification.state === Chaining.Step.STATE_COMPLETED) {
            // }
        }

        function chainAlwaysHandler(res) {
            // hobs.log('%s Chain %s - Execution End %s', _chain.LOG_PREFIX, _chain.id(), res);

            $(_chain).trigger(Chaining.Chain.CHAIN_EXECUTED, [{type: Chaining.Chain.CHAIN_EXECUTED, passed: _chain.hasPassed()}]);
        }

        // Handle chain notifications and propagate it to the current step
        this.dfr()
            .progress(chainProgressHandler)
            .always(chainAlwaysHandler);

        execFct.call(_chain, options, stepsToExecute);
    }

    function execStepFct(options, stepsToExecute) {
        var _chain = this,
            chainStepResults = [],
            execIdx = 0;


        function execStep(prevRes) {
            _chain.currentStep_Idx = execIdx;
            _chain.currentStep_ = stepsToExecute.shift();

            /** Step Execution End **/
            function stepAlwaysHandler(res) {
                // // hobs.log('%s dfr.always: %s', _chain.LOG_PREFIX, JSON.stringify(res));

                $(_chain).trigger(Chaining.Chain.STEP_EXECUTED, [{type: Chaining.Chain.STEP_EXECUTED, step: _chain.steps_[execIdx]}]);

                // hobs.log('%s %s', _chain.LOG_PREFIX, _chain.getProgress());

                if (_chain.steps_[execIdx]._state === Chaining.Step.STATE_CANCELED) {
                    return;
                }
                chainStepResults.push(res);
                execIdx++;
                execStep(res);
            }

            if (_chain.currentStep_) {
                // hobs.log('%s Executing step [%d] %o', _chain.LOG_PREFIX, (_chain.getStepIndex(_chain.currentStep_)+1), _chain.currentStep_);

                _chain.currentStep_
                    .exec(options)
                    .always(stepAlwaysHandler);
            }
            else if (prevRes !== Chaining.Step.STATE_CANCELED) {
                _chain.done(_chain.hasPassed() ? Chaining.Step.STATE_PASSED : Chaining.Step.STATE_FAILED, chainStepResults);
            }

        }
        execStep();
    }


})(window.hobs, window.hobs.Chaining, window.$);


;

(function (hobs, Chaining, $) {
    "use strict";

    /**
      @class IntervalStep
      @classdesc A repeating Step using a poll interval
      @extends Chaining.Step
      @param {function} [fct=Chaining.Step.prototype.defaultExec] - The function executed by the step
      @param {object} [options={}] - Extra options passed to the step to control its execution
      @memberof hobs.Chaining
    */
    Chaining.IntervalStep = function (fct, options) {
        var _step = this,
            _options = $.extend({
                timeout: hobs.config.action_timeout,
                pollInterval: Chaining.DEFAULT_POLL_INTERVAL,
                timeoutState: Chaining.Step.STATE_FAILED
            }, options);

        this.checkFct = fct || Chaining.defaultActions.returnFalse;

        Chaining.Step.call(_step, intervalStepExecFct, _options);
    };

    hobs.utils.definePrototype(
        Chaining.IntervalStep,
        Chaining.Step
    );



    /**
     * Private functions
     **/

    /**
     * Step execution function with interval check
     **/
    function intervalStepExecFct(options) {

        var _step = this,
            opts = $.extend({}, options),
            timeout = opts.timeout,
            interval = null;

        function intFct() {
            if (_step.checkFct(_step.dfr(), opts) === true) {
                clearInterval(interval);
                _step.done(Chaining.Step.STATE_PASSED);
            } else if (timeout <= opts.pollInterval) {
                clearInterval(interval);
                _step.done(opts.timeoutState);
            } else {
                timeout -= opts.pollInterval;
            }
        }

        function progressHandler(notification) {
            if (notification.state === Chaining.Step.STATE_CANCELED) {
                clearInterval(interval);
            } else if (notification.state === Chaining.Step.STATE_PAUSED) {
                clearInterval(interval);
            } else if (notification.state === Chaining.Step.STATE_RESUMED) {
                interval = setInterval(intFct, opts.pollInterval);
            }
        }

        function alwaysHandler(res) {
            clearInterval(interval);
        }

        _step.dfr()
            .progress(progressHandler)
            .always(alwaysHandler);

        interval = setInterval(intFct, opts.pollInterval);
    }

})(window.hobs, window.hobs.Chaining, window.$);


;

(function (hobs, Chaining, $) {
    "use strict";

    /**
      @class PollCheckStep
      @classdesc A repeating Step using a poll interval with checking features
      @extends Chaining.Step
      @param {function} [checkFct={@link Chaining.defaultActions}] - The function executed by the step
      @param {object} [options={timeout: 2500, pollInterval: {@link Chaining.DEFAULT_POLL_INTERVAL}, timeoutState: {@link Chaining.Step.STATE_FAILED}}] - Extra options passed to the step to control its execution
      @memberof hobs.Chaining
    */
    Chaining.PollCheckStep = function (checkFct, options) {
        var _step = this,
            _options = $.extend({
                pollInterval: Chaining.DEFAULT_POLL_INTERVAL,
                timeoutState: Chaining.Step.STATE_FAILED
            }, options);

        this._checkFct = checkFct || Chaining.defaultActions.returnFalse;

        Chaining.Step.call(_step, this.pollCheclExecFct, _options);
    };

    hobs.utils.definePrototype(
        Chaining.PollCheckStep,
        Chaining.Step,
        {
            'pollCheclExecFct' : function (options) {
                var execOptions = $.extend(true, {timeout: hobs.config.action_timeout}, options);

                delete execOptions.checkTrueFct;
                delete execOptions.timeoutFct;
                delete execOptions.checkFalseFct;

                var _step = this,
                    opts = $.extend({}, options),
                    timeout = execOptions.timeout,
                    pollTimeout = null;
                    // interval = null;

                _step.dfr()
                    .progress(progressHandler)
                    .always(alwaysHandler);

                if (opts.beforeCheckFct) {
                    opts.beforeCheckFct(opts, _step.dfr());
                }

                var genericRejectedFnHandler = function(fct) {
                    return function(err, dfr) {
                        _step.done(
                            Chaining.Step.STATE_FAILED,
                            {
                                args: [fct, err, err.stack, execOptions],
                                msg: 'Executing ${check function:0} threw ${error:1} (${stack:2})'
                            }
                        );
                        dfr = null;
                    };
                };

                function checkFnResolved(retValue, dfr) {
                    // if (pollTimeout === null) {
                    //     pollTimeout = setTimeout(intFct, opts.pollInterval);
                    // }
                    // else
                     if (retValue !== false) {
                        // clearInterval(interval);

                        if (opts.checkTrueFct) {
                            hobs.utils.safeApplyFn(opts.checkTrueFct, _step, [execOptions, _step.dfr()]).then(null, genericRejectedFnHandler(opts.checkTrueFct));
                        }
                        else {
                            _step.done(Chaining.Step.STATE_PASSED);
                        }
                    }
                    else {
                        if (opts.checkFalseFct) {
                            hobs.utils.safeApplyFn(opts.checkFalseFct, _step, [execOptions, _step.dfr()]).then(null, genericRejectedFnHandler(opts.checkFalseFct));
                        }

                        if ((performance.now() - timestamp) >= timeout) {
                            // clearInterval(interval);

                            if (opts.timeoutFct) {
                                hobs.utils.safeApplyFn(opts.timeoutFct, _step, [execOptions, _step.dfr()]).then(null, genericRejectedFnHandler(opts.timeoutFct));
                            } else {
                                _step.done(opts.timeoutState);
                            }
                        }
                        else {
                            pollTimeout = setTimeout(intFct, opts.pollInterval);
                        }
                    }
                    dfr = null;
                }

                function checkFnRejected(err, dfr) {
                    _step.done(
                        Chaining.Step.STATE_FAILED,
                        {
                            args: [_step._checkFct, err, options],
                            msg: 'Executing ${check function:0} threw ${error:1}'
                        }
                    );
                    dfr = null;
                }

                function progressHandler(notification) {
                    if (notification.state === Chaining.Step.STATE_CANCELED) {
                        clearTimeout(pollTimeout);
                    } else if (notification.state === Chaining.Step.STATE_PAUSED) {
                        clearTimeout(pollTimeout);
                    } else if (notification.state === Chaining.Step.STATE_RESUMED) {
                        pollTimeout = setTimeout(intFct, opts.pollInterval);
                        // interval = setInterval(intFct, opts.pollInterval);
                    }
                }

                function alwaysHandler(res) {
                    clearTimeout(pollTimeout);
                }

                function intFct() {
                    hobs.utils.safeApplyFn(_step._checkFct, _step, [opts, _step.dfr()]).then(checkFnResolved, checkFnRejected);
                }

                var timestamp = performance.now();
                intFct();
            }
        }
    );

})(window.hobs, window.hobs.Chaining, window.$);


;

(function (hobs, Chaining, $) {
    "use strict";

    /**
      @class WaitStep
      @classdesc A Step forcing to wait (2.5s. by default)
      @extends Chaining.IntervalStep
      @param {object} [options={timeout: 2500, timeoutState: {@link Chaining.Step.STATE_PASSED}}] - Extra options passed to the step to control its execution
      @memberof hobs.Chaining
    */
    Chaining.WaitStep = function (options) {
        var _options = $.extend({timeout: hobs.config.action_timeout, timeoutState: Chaining.Step.STATE_PASSED}, options);

        Chaining.IntervalStep.call(this, null, _options);
    };

    hobs.utils.definePrototype(
        Chaining.WaitStep,
        Chaining.IntervalStep
    );

})(window.hobs, window.hobs.Chaining, window.$);


;

(function (hobs, Chaining, $) {
    "use strict";

    /**
     * Variables / Constants
     **/

    /**
     * @ignore
     */
    hobs._customActions = [];

    /**
     * @ignore
     */
    var _registeredTestSuites = [];



    /**
     * REMARK: by default, a {@link hobs.TestSuite} is automatically registered to Hobbes on instantiation
     *
     * @returns {Array.<hobs.TestSuite>} All the test suites in array
     **/
    hobs.getTestSuites = function () {
        return _registeredTestSuites;
    };

    /**
     * REMARK: by default, a {@link hobs.TestSuite} is automatically registered to Hobbes on instantiation
     *
     * @returns {hobs.TestSuite[]} All the registered test suites in array
     **/
    hobs.getRegisteredTestSuites = function () {
        var suites = [];

        for (var i=0; i < _registeredTestSuites.length; i++) {
            if (_registeredTestSuites[i].options("register") === true) {
                suites.push(_registeredTestSuites[i]);
            }
        }

        return suites;
    };

    /**
     * @ignore
     **/
    hobs.clearRegisteredTestSuites = function () {
        _registeredTestSuites = [];
    };



    /**
     * Register custom test actions under a specific namespace
     *
     * @param {string} ns - Namespace name to add in chaining process of {@link hobs.TestCase}
     * @param {Array.<hobs.TestStep>} actions - Array of actions to add under the given namespace
     **/
    hobs.registerCustomActions = function (ns, actions) {
        hobs._customActions.push({
            namespace: ns,
            actions: actions
        });
    };

    hobs.registerTestSuite = function(testsuite) {
        _registeredTestSuites.push(testsuite);
    };

    hobs.getResult = function(options) {

        var res = {
            passed: this.state() === Chaining.Step.STATE_PASSED,
            state: this.state(),
            type: this.type,
            id: this.id || '',
            name: this.name ? this.name : ''
        };

        var msg = null;

        if (this['res-msg-'+this.state()]) {
            msg = $.isFunction(this['res-msg-'+this.state()]) ? this['res-msg-'+this.state()].call(this, options) : this['res-msg-'+this.state()];
        }

        if (msg) {
            res.msg = msg;
        }
        else {
            res.msg =  hobs.reporters.TXT.call(this, res);
        }

        if (this.duration) {
            res.duration =  this.duration ? this.duration() : -1;
        }

        return res;
    };



    /**
     * Polyfill log function
     *
     * @param {...string}
     * @memberof hobs
     *
     * @see {@link hobs.config.debug} To enable/disable debug logging
     **/
    hobs.log = function () {
        if (hobs.config.debug && console) {
            var args = Array.prototype.slice.call(arguments);
            console.log.apply(console, args);

            return args;
        } else {
            return null;
        }
    };



})(window.hobs, window.hobs.Chaining, $);


;

(function (hobs, Chaining, $) {
    'use strict';



    /**
     * @class
     * @alias hobs.TestStep
     * @classdesc A extended Step with testing features
     *
     * @extends hobs.Chaining.Step
     *
     * @param {string} id - The id of the step
     * @param {string} name - The name of the step
     * @param {hobs.Chaining.Step} step - The step to add to the chain
     * @param {object} [options={}] - Extra options passed to the step to control its execution
     *
     **/
    hobs.TestStep = function (id, name, step, options) {
        this.id = id;
        this.name = name;
        this.uuid = hobs.utils.getRandomString(32);
        this._step = step;
        this._result = null;
        this._testChain = null;
        // this._options = options;
        // Init execution timing properties
        this._timing = {start: -1, end: -1};

        Object.defineProperty(this, "_execData", {enumerable: false, configurable: true, value: {}});

        Chaining.Step.call(this, this.execTestStepFct, options);
    };

    // Constants
    hobs.TestStep.STEP_EXECUTED = 'teststepExecuted';
    hobs.TestStep.EXEC_PHASE_BEFORE = 'before';
    hobs.TestStep.EXEC_PHASE_AFTER = 'after';

    hobs.TestStep.prototype = new Chaining.Step();

    /**
     * @ignore
     */
    hobs.TestStep.prototype.constructor = hobs.TestStep;
    // hobs.TestStep.prototype.classname = 'hobs.TestStep';

    /**
     * Get/set execution metadata of the test step
     *
     * @function hobs.TestStep#execData
     *
     * @param {string} key   The name of the option property
     * @param {*}      value The value to set the option property to
     *
     * @example
     * // Init TestStep
     * var step = new hobs.TestStep('ts1', 'Test Step #1');
     * // Execution metadata is set to an empty object by default
     *
     * // Get all the options as an Object
     * step.execData(); // => {}
     *
     * // Get the value of a specific option property
     * step.execData('prop1'); // => 'string'
     * step.execData('prop2'); // => 12
     *
     * // Set the value of a specific option property
     * step.execData('prop1', true);
     * step.execData('prop2', 123);
     * step.execData(); // => {prop1: true, prop2: 123}
     **/
    hobs.TestStep.prototype.execData = function (key, value) {
        if (!this._execData) {
            return null;
        }
        else if (key === undefined && value === undefined) {
            return this._execData;
        }
        else if (key && value === undefined) {
            return this._execData[key];
        }
        else {
            this._execData[key] = value;
        }
    };

    /**
     * Get the duration of the test step execution
     *
     * @function hobs.TestStep#duration
     *
     * @param {string} [format='ms'] Specific format to convert the duration to. By default, milliseconds
     *
     * @returns {number} The duration of execution in a specific format. Returns -1 if the test step has not been completely executed.
     **/
    hobs.TestStep.prototype.duration = function (format) {
        format = format || "ms";

        if (this._timing.start > 0 && this._timing.end > 0) {
            var duration = this._timing.end - this._timing.start;

            switch(format) {
                case "s":
                    duration = duration / 1000;
                    break;
            }

            return duration;
        }
        else {
            return -1;
        }
    };

    hobs.TestStep.prototype.step = function () {
        return this._step;
    };

    hobs.TestStep.prototype.setStep = function (step) {
        this._step = step;
    };

    hobs.TestStep.prototype.testChain = function () {
        return this._testChain;
    };

    hobs.TestStep.prototype.executionEndHandler = function (res) {
        this.result();

        this._testChain = null;

        this._step = null;

        // Reset exec data
        Object.defineProperty(this, "_execData", {enumerable: false, configurable: true, value: {}});
    };

    // // /**
    // //  * Get/Set TestStep options
    // //  * @override
    // //  **/
    // hobs.TestStep.prototype.options = function (name, value) {
    //     if (name === undefined && value === undefined) {
    //         return this._options;
    //     }
    //     else if ($.type(name) === 'string' && value === undefined) {
    //         return this._options[name];
    //     }
    //     else {
    //         this._options[name] = value;
    //     }
    // };



    /**
     * Cancels test step execution
     *
     * @function hobs.TestStep#cancel
     *
     * @override
     **/
    hobs.TestStep.prototype.cancel = function () {
        this.demoModeOut();
        Chaining.Step.prototype.cancel.call(this);
    };



    hobs.TestStep.prototype.execTestStepFct = function (opts) {
        var _teststep = this;

        _teststep._result = null;

        var options = _teststep.generateTestChain(opts);

        function progressHandler(notification) {
            if (notification.state === Chaining.Step.STATE_PAUSED) {
                _teststep._testChain.pause();
            }
            else if (notification.state === Chaining.Step.STATE_RESUMED) {
                _teststep._testChain.resume();
            }
        }

        function alwaysHandler(data) {
            _teststep._timing.end = Date.now();

            _teststep._state = _teststep._testChain.state();

            _teststep.executionEndHandler(data);

            _teststep.demoModeOut();

            _teststep.done(_teststep._state);
        }

        _teststep.dfr().progress(progressHandler);

        _teststep._timing.start = Date.now();

        _teststep._testChain
            .exec(options)
            .always(alwaysHandler);
    };



    /**
     * Returns a represention of the result of the test step execution.
     *
     * @function hobs.TestStep#result
     *
     * @param {string}  [format]            Use a specific {@link hobs.reporters} to render the result.
     * @param {boolean} [withDetails=false] By default, {@link hobs.reporters} do not process children
     *                                      of successful test steps. Force this parameter to true to
     *                                      also get them.
     *
     * @returns {object} An object representing the result of the execution.
     **/
    hobs.TestStep.prototype.result = function (format, withDetails) {

        if (this._result) {
            return this._result;
        }

        var res = _getResult.call(this, this._options),
            steps = this.testChain() ?
                        this.testChain().steps()
                        :
                        this.step() ?
                            [this.step()]
                            :
                            [];

        for (var i=0; i < steps.length; i++) {
            var step = steps[i];

            if ($.isFunction(step.result)) {
                var sRes = step.result();
                if(!res.hasOwnProperty('steps')) {
                    res.steps = [];
                }

                res.steps.push(sRes);
            }
        }

        this._result = res;

        if (format) {
            return hobs.reporters.format(this, format, withDetails);
        }

        return res;
    };



    /**
     * Returns a clone of the teststep
     * @function hobs.TestStep#clone
     *
     * @returns {hobs.TestStep}
     **/
    hobs.TestStep.prototype.clone = function () {
        return jQuery.extend(true, new this.constructor(), this);
    };

    /**
     * @private
     * @ignore
     **/
    hobs.TestStep.prototype.generateTestChain = function (opts) {
        var _teststep = this,
            extOptions = hobs.handleDynParameters(_teststep.options(), opts),
            execOptions = $.extend(true, {}, opts, extOptions),
            _step = hobs.handleDynParameters(_teststep._step, execOptions);

        // Init test step chain of execution
        _teststep._testChain = new Chaining.Chain();

        // Handle 'before' options flags
        $.each(['pacingDelay', 'delay', 'delayBefore', 'execBefore', 'before'], function(idx, option) {
            if (execOptions[option]) {
                handleOption(_teststep, [].concat(execOptions[option]), hobs.TestStep.EXEC_PHASE_BEFORE);
                delete execOptions[option];
            }
        });

        // If not null, add the step
        if (_step !== undefined && _step !== null) {
            _teststep._testChain.addStep(_step);
        }

        // Handle 'after' options flags
        $.each(['execAfter', 'after', 'delayAfter', 'demoMode'], function(idx, option) {
            if (execOptions[option]) {
                handleOption(_teststep, [].concat(execOptions[option]), hobs.TestStep.EXEC_PHASE_AFTER);
                delete execOptions[option];
            }
        });

        return execOptions;
    };



    /**
     * Privates
     **/

    function handleOption(teststep, options, phase) {
        $.each(options, function(idx, option) {
            var stepTE = null;

            // Test element. Clone it and add it to the chain
            if(hobs.TestStep.prototype.isPrototypeOf(option)) {
                stepTE = option.clone();
                stepTE.execData('phase', phase);
            }
            // Function. Wrap it in a hobs.actions.core.execFct and add it to the chain
            else if ($.isFunction(option)) {
                stepTE = new hobs.actions.core.execFct(option);
                stepTE.execData('args', [option]);
                stepTE.execData('msg', 'Executing ${function:0} ' + phase);
                stepTE.execData('phase', phase);
            }
            // Number. Wrap it in a hobs.actions.core.wait and add it to the chain
            else if ((typeof(option) !== "boolean") && !isNaN(option)) {
                stepTE = new hobs.actions.core.wait(option);
                stepTE.execData('args', [option]);
                stepTE.execData('msg', 'Waiting ${0} ms. ' + phase);
                stepTE.execData('phase', phase);
            }

            if (stepTE) {
                teststep._testChain.addStep(stepTE);
            }
        });
    }

    function _getResult(options) {
        var msg = null,
            res = {
                passed: this.state() === Chaining.Step.STATE_PASSED,
                state: this.state(),
                type: this.type,
                id: this.id,
                uuid: this.uuid,
                name: this.name,
                duration: this.duration(),
                report: {
                     msg: 'TODO',
                     params: null
                }
            };

        if (this.execData('phase')) {
            res.phase = this.execData('phase');
        }

        if (this.execData('args')) {
                res.report.params = this.execData('args');
        }

        if (this.execData('msg')) {
            msg = this.execData('msg');
            res.report.msg = msg;
        }
        else if (!msg && this['res-msg-'+this.state()]) {
            msg = $.isFunction(this['res-msg-'+this.state()]) ? this['res-msg-'+this.state()].call(this, options) : this['res-msg-'+this.state()];

            res.report.msg = msg;
        }
        // else if (this.execData('res')) {
        //     msg = this.execData('res').msg;
        //     res.report.msg = msg;
        // }

        if (msg) {
            if (($.type(msg) === 'string') && msg.indexOf('${') > -1) {
                msg =  hobs.reporters.TXT.call(this, res);
            }

            res.msg = msg;
        }

        return res;
    }



    /**
     * TODO - Reimplement Demo Mode...
     **/

    /**
     * @private
     * @ignore
     **/
    hobs.TestStep.prototype.clearDemoModeHighlight = function () {
        if(this._demoModeHighlightDOMEl) {
            this._demoModeHighlightDOMEl.remove();
            this._demoModeHighlightDOMEl = null;
        }
    };

    /**
     * @private
     * @ignore
     **/
    hobs.TestStep.prototype.setDemoModeHighlightDOMEl = function (el) {
        this._demoModeHighlightDOMEl = el;
    };

    hobs.TestStep.prototype._demoModeHighlightDOMEl = null;

    hobs.TestStep.prototype.demoModeOut = function () {
        this.clearDemoModeHighlight();
    };


})(window.hobs, window.hobs.Chaining, $);


;

(function(hobs, $) {
    "use strict";

    /**
     * @namespace
     *
     * @desc Classes extending {@link hobs.TestStep}
     */
    hobs.teststeps = hobs.teststeps || {};

    hobs.teststeps.namespace = "hobs.teststeps";

})(window.hobs, $);


;

(function (hobs, Chaining, $) {
    "use strict";

    /**
     * A TestStep that pollchecks truthness of a given function
     *
     * @class PollCheckTestStep
     * @extends hobs.TestStep
     *
     * @param {string}      id                                                      The id of the step
     * @param {string}      name                                                    The name of the step
     * @param {function}    [checkFct={@link Chaining.defaultActions.returnFalse}]  The function executed by the step
     * @param {object}      [options={}]                                            Extra options passed to the step to control its execution
     *
     * @memberof hobs.teststeps
     */
    hobs.teststeps.PollCheckTestStep = function (id, name, checkFct, options) {
        var _options = $.extend({}, {pollInterval: hobs.config.poll_interval}, options),
            _checkFct = checkFct,
            _pollCheckStep = new Chaining.PollCheckStep(_checkFct, _options);

        hobs.TestStep.call(this, id, name, _pollCheckStep, _options);
    };

    hobs.utils.definePrototype(
        hobs.teststeps.PollCheckTestStep,
        hobs.TestStep
    );

})(window.hobs, window.hobs.Chaining, $);


;

(function (hobs, Chaining, $) {
    "use strict";

    /**
     * A TestStep that checks existence of a DOM Element based on given jQuery selector
     *
     * @class jQSelectorPollCheckTestStep
     * @extends hobs.TestStep
     *
     * @param {string} id - The id of the step
     * @param {string} name - The name of the step
     * @param {string} selector - jQuery selector of the element to look for in the DOM
     * @param {object} [options] - Extra options passed to the step to control its execution
     *
     * @memberof hobs.teststeps
     **/
    hobs.teststeps.jQSelectorPollCheckTestStep = function (id, name, selector, options) {
        var _self = this,
            _options = $.extend({}, {pollInterval: hobs.config.poll_interval}, options);

        function parseSelectorFn(opts) {
            var sel_dyn = hobs.handleDynParameters(selector, opts);
            _self.execData('args', [sel_dyn, opts]);
        }

        function _checkFct(opts) {
            // Process dynamic parameters
            var el = hobs.utils.dom.getJQElFromSelector(_self.execData('args')[0], opts);
            _self.execData('element', el);

            return el.length > 0;
        }

        _options = $.extend(
            {pollInterval: hobs.config.poll_interval},
            options,
            {
                beforeCheckFct: parseSelectorFn,
                demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY
            });

        var _pollCheckStep = new Chaining.PollCheckStep(_checkFct, _options);

        hobs.TestStep.call(this, id, name, _pollCheckStep, _options);
    };

    hobs.utils.definePrototype(
        hobs.teststeps.jQSelectorPollCheckTestStep,
        hobs.TestStep
    );

})(window.hobs, window.hobs.Chaining, $);


;

(function (hobs, Chaining, $) {
    "use strict";

    /**
     * A Chain with testing extra features
     * @class TestChain
     * @extends hobs.chaining.Chain
     *
     * @param {string} id - The id of the test chain
     * @param {string} name - The name of the test chain
     * @param {object} [options] - Extra options passed to the test chain
     *
     * @memberof hobs.teststeps
     *
     * @ignore
     **/
    hobs.teststeps.TestChain = function (id, name, options) {
        this.id = id;
        this.name = name;

        var _testChain = this;
        var extendOptions = $.extend({ execStepFct: execStepFct }, options);
        Chaining.Chain.call(_testChain, extendOptions);
    };

    hobs.utils.definePrototype(
        hobs.teststeps.TestChain,
        Chaining.Chain,
        {
            'type' : "hobs.teststeps.WaitTestStep",
            'res-msg-passed' : 'Test Chain passed',
            'res-msg-failed' : 'Test Chain failed'
        }
    );

    // // Fix jQuery event binding on Class Object
    // // http://www.khaitu.com/articles/jquery-event-binding-to-a-prototypical-instance
    // hobs.teststeps.TestChain.prototype.length = 1;

    /**
     * @override
     **/
    hobs.teststeps.TestChain.prototype.result = function () {
        var res = hobs.getResult.call(this, this._options),
            steps = this.steps(),
            stepsResult = [];

        for (var i=0; i < steps.length; i++) {
            stepsResult.push(steps[i].result());
        }

        res.steps = stepsResult;

        return res;
    };

    hobs.teststeps.TestChain.prototype._retryCount = 0;

    hobs.teststeps.TestChain.STEP_EXECUTED = "testChainStepExecuted";

    /**
     * @property {string} SKIP_ON_FAIL_CHAIN_EXEC_MODE - exec mode to skip execution of remaining steps on failure
     **/
    hobs.teststeps.TestChain.SKIP_ON_FAIL_CHAIN_EXEC_MODE = "skipOnFailExecMode";

    /**
     * @property {string} RETRY_ON_FAIL_CHAIN_EXEC_MODE - exec mode to retry execution of steps in a chain
     **/
    hobs.teststeps.TestChain.RETRY_ON_FAIL_CHAIN_EXEC_MODE = "retryOnFailExecMode";

    function execStepFct(options, stepsToExecute) {
        var _chain = this,
            chainStepResults = [],
            execIdx = 0,
            TestChain = hobs.teststeps.TestChain;


        function execStep(prevRes) {
            _chain.currentStep_Idx = execIdx;
            _chain.currentStep_ = stepsToExecute.shift();

            /** Step Execution End **/
            function stepAlwaysHandler(res) {
                var nextStep = false;
                // // hobs.log('%s dfr.always: %s', _chain.LOG_PREFIX, JSON.stringify(res));

                $(_chain).trigger(Chaining.Chain.STEP_EXECUTED, [{type: Chaining.Chain.STEP_EXECUTED, step: _chain.steps_[execIdx]}]);

                // hobs.log('%s %s', _chain.LOG_PREFIX, _chain.getProgress());

                if (_chain.steps_[execIdx]._state === Chaining.Step.STATE_CANCELED) {
                    return;
                }
                else if (_chain.steps_[execIdx]._state === Chaining.Step.STATE_FAILED) {
                    if (_chain.options().execMode && _chain.options().execMode === TestChain.SKIP_ON_FAIL_CHAIN_EXEC_MODE) {
                        $(_chain).trigger('chainStepFailed', [_chain.currentStep_]);
                        _chain.done(_chain.hasPassed() ? Chaining.Step.STATE_PASSED : Chaining.Step.STATE_FAILED);
                        return;
                    } else if (_chain.options().execMode && _chain.options().execMode === TestChain.RETRY_ON_FAIL_CHAIN_EXEC_MODE) {
                        if (hobs.TestCase.prototype.isPrototypeOf(_chain.currentStep_)) {
                            if ( _chain._retryCount < _chain.options().maxRetries) {
                                $(_chain).trigger('chainStepFailed', [_chain.currentStep_]);
                                _chain._retryCount++;
                                // console.log("retry "+_chain._retryCount);
                                _chain.steps_[execIdx].retryCount_ = _chain._retryCount;
                                stepsToExecute.unshift(_chain.currentStep_);
                                res = prevRes;
                            // else step passed so continue chain execution
                            } else {
                                nextStep = true;
                            }
                        } else {
                            nextStep = true;
                        }
                    }
                // else step passed so continue chain execution
                } else {
                    nextStep = true;
                }
                if (nextStep) {
                        _chain._retryCount = 0;
                        execIdx += 1;
                        chainStepResults.push(res);
                }
                execStep(res);
            }

            if (_chain.currentStep_) {
                // hobs.log('%s Executing step [%d] %o', _chain.LOG_PREFIX, (_chain.getStepIndex(_chain.currentStep_)+1), _chain.currentStep_);

                _chain.currentStep_
                    .exec(options)
                    .always(stepAlwaysHandler);
            }
            else if (prevRes !== Chaining.Step.STATE_CANCELED) {
                _chain.done(_chain.hasPassed() ? Chaining.Step.STATE_PASSED : Chaining.Step.STATE_FAILED, chainStepResults);
            }

        }
        execStep();
    }

})(window.hobs, window.hobs.Chaining, $);


;

(function (hobs, Chaining, $) {
    "use strict";

    /**
     * A TestStep that checks if given function returns true
     *
     * @class IsTrueTestStep
     * @extends hobs.teststeps.PollCheckTestStep
     *
     * @param {function} [isTrue=hobs.defaultActions.returnFalse] - The function to assert to true
     * @param {object} [options] - Extra options passed to the step to control its execution
     *
     * @memberof hobs.teststeps
     **/
    hobs.teststeps.IsTrueTestStep = function (isTrue, options) {
        var _options = $.extend({}, {pollInterval: hobs.config.poll_interval}, options),
            _checkFct = isTrue || Chaining.defaultActions.returnFalse;

        hobs.teststeps.PollCheckTestStep.call(this, null, null, _checkFct, _options);
    };

    hobs.utils.definePrototype(
        hobs.teststeps.IsTrueTestStep,
        hobs.teststeps.PollCheckTestStep
    );

})(window.hobs, window.hobs.Chaining, $);


;

(function (hobs, Chaining, $) {
    "use strict";

    /**
     * A TestStep to force execution to wait for a fixed amount of ms.
     * Waiting time configured via `options.timeout` property
     *
     * @class WaitTestStep
     * @extends hobs.TestStep
     *
     * @param {string}          id                          The id of the step
     * @param {string}          name                        The name of the step
     * @param {TestStepOptions} [options={timeout: 2500}]   Extra options passed to the step to control its execution
     *
     * @memberof hobs.teststeps
     **/
    hobs.teststeps.WaitTestStep = function (options) {
        var _options = $.extend({timeout: 2500}, options),
            _waitStep = new Chaining.WaitStep(_options);

        hobs.TestStep.call(this, null, null, _waitStep, _options);

        this.execData('args', [options.timeout]);
    };

    hobs.utils.definePrototype(
        hobs.teststeps.WaitTestStep,
        hobs.TestStep,
        {
            'type' : "hobs.teststeps.WaitTestStep",
            'res-msg-passed' : 'Waited ${0} ms.'
        }
    );

})(window.hobs, window.hobs.Chaining, $);


;

(function (hobs, Chaining, TestChain, $) {
    "use strict";

    /**
     * A test case
     *
     * @class
     * @alias hobs.TestCase
     * @extends hobs.TestStep
     *
     * @param {string} name - The name of the test case
     * @param {TestStepOptions} [options] - Extra options passed to the test case
     **/
    hobs.TestCase = function (name, options, testcaseFn) {
        var _testCase = this;

        this._result = null;

        _testCase._tcSteps = [];
        _testCase.testcaseChain = new TestChain('testcaseChain - ' + hobs.utils.getIdFromString(name), 'testcaseChain - ' + name, {logPrefix: '    '});

        hobs.TestStep.call(_testCase, hobs.utils.getIdFromString(name), name, null, options);

        _testCase.initTestActions();

        if (typeof(testcaseFn) === 'function') {
            _testCase.testcaseFn = testcaseFn;
        }

        return _testCase;
    };


    hobs.utils.definePrototype(
        hobs.TestCase,
        hobs.TestStep,
        {
            'type' : hobs.namespace + ".TestCase",
            // 'asserts' : {},
            // 'config' : {},

            'res-msg-passed' : function () { return 'TestCase Passed! (' + this.name + ')'; },
            'res-msg-failed' : function () { return 'TestCase Failed! (' + this.name + ')'; }
        }
    );

    /**
     * @function hobs.TestCase#done
     *
     * @override
     **/
    hobs.TestCase.prototype.done = function (state, res) {

        // this._result = this.computeResult();

        this.testcaseChain = null;

        $(this).trigger(hobs.TESTCASE_FINISHED, [this]);

        hobs.TestStep.prototype.done.call(this, state, res);
    };

    hobs.TestCase.prototype.hasPassed = function () {
        if (this.state() !== Chaining.Step.STATE_PASSED) {
            return false;
        }
        return true;
    };

    /**
     * @function hobs.TestCase#cancel
     *
     * @override
     **/
    hobs.TestCase.prototype.cancel = function () {
        var _testcase = this;

        function cancelParent() {
            hobs.TestStep.prototype.cancel.call(_testcase);
        }

        $(this.testcaseChain).one(Chaining.Chain.CHAIN_EXECUTED, cancelParent);

        this.testcaseChain.cancel();
    };

    /**
     * @function hobs.TestCase#result
     *
     * @override
     **/
    hobs.TestCase.prototype.result = function(format, withDetails) {
        if (format) {
            return hobs.reporters.format(this, format, withDetails);
        }

        if (this._result) {
            return this._result;
        }
        else {
            return this.computeResult();
        }
    };

    hobs.TestCase.prototype.computeResult = function () {
        var res = hobs.TestStep.prototype.result.call(this), //getResult.call(this, this._options),
            steps = [],//getTestCases(),
//            steps = this.testcaseChain ? this.testcaseChain.steps() : [],//getTestCases(),
            stepsResult = [];

        if (this.testChain() !== null) {
            steps = this.testChain().steps();
            res.passed = this.testChain().state() === Chaining.Step.STATE_PASSED;
            res.state = this.testChain().state();
        }
        else if (this.testcaseChain !== null) {
            steps = this.testcaseChain.steps();
            var testcaseChainResult = this.testcaseChain.result();
            res.passed = testcaseChainResult.passed;
            res.state = (testcaseChainResult.passed ? Chaining.Step.STATE_PASSED : Chaining.Step.STATE_FAILED);
//            res = hobs.TestStep.prototype.result.call(this)
        }

        function getStepResultObj(dest, step) {
            var sRes = $.isFunction(step.result) ? step.result() : step.state();
            //sRes.options = step.options();

            dest.push(sRes);
        }

        function getSingleResult(index, tcChainStep) {
                getStepResultObj(stepsResult, tcChainStep);
        }

        for (var i=0; i < steps.length; i++) {
            var step = steps[i];

            if (step === this.testcaseChain) {
                $(step.steps()).each(getSingleResult);
            }
            else {
                getStepResultObj(stepsResult, step);
            }
        }

        res.steps = stepsResult;
        res.duration = this.duration();
        res.retryCount = this.retryCount_ !== undefined ? this.retryCount_ : 0;

        return res;
    };


    /**
     * @function hobs.TestCase#exec
     *
     * @override
     **/
    hobs.TestCase.prototype.exec = function (options) {
        // Reset test case result
        var _testcase = this;

        this._result = null;

        this.testcaseChain = new TestChain('testcaseChain', 'testcaseChain', {execMode: TestChain.SKIP_ON_FAIL_CHAIN_EXEC_MODE});

        $(this.testcaseChain).on('chainStepFailed', function(event, step) {
            $(hobs).trigger(hobs.TESTCASE_FAILED, [_testcase, step]);
        });

        if (this.testcaseFn) {
            this._tcSteps = [];

            if (this.testcaseFn.constructor.name === 'GeneratorFunction') {
                var opts = $.extend({}, options);

                if (this.options('each')) {
                    opts = $.extend({}, this.options('each'), opts);
                }

                if (this.options('demoMode') === true) {
                    opts.demoMode = true;
                }

                if($.isNumeric(hobs.config.pacing_delay) && hobs.config.pacing_delay > 0) {
                    opts.pacingDelay = hobs.config.pacing_delay;
                }

                this.initTestActions(true)['yieldThis'](_testcase.testcaseFn);

                // var stepFct = function(opts2) {
                //     var callingStep = this;
                //     spawn.call(_testcase, _testcase.testcaseFn, opts2).then(function(err) {
                //         callingStep.done(hobs.Chaining.Step.STATE_PASSED);
                //     });
                // };
                //
                // var step = new hobs.Chaining.Step(stepFct);
                //
                // var genTestStep = new hobs.TestStep(null, null, step, opts);
                //
                // this.testcaseChain.addStep(genTestStep);
                // spawn.call(this, this.testcaseFn, opts).then(function(err, asd) {
                //     console.log('done');
                //
                //     // _testcase.exec().then(function() {
                //         var testcaseChainResult = _testcase.testcaseChain.result();
                //
                //         _testcase.done((testcaseChainResult.passed ? Chaining.Step.STATE_PASSED : Chaining.Step.STATE_FAILED));
                //     // });
                // });
                //
                // return;
            }
            else {
                this.initTestActions(true).testcaseFn.call(this, this);
            }

        }

        for (var i=0; i < this._tcSteps.length; i++) {
            var tcStep = this._tcSteps[i];
            var fctRef = tcStep.action;
            var testAction = new fctRef();

            fctRef.apply(testAction, tcStep.args);

            // Handle TestCase specific 'each' parameter
            // Pass it to each step as standard parameters
            if (this.options('each')) {
                testAction._options = $.extend({}, this.options('each'), testAction._options);
            }

            if (this.options('demoMode') === true) {
                testAction.options("demoMode", true);
            }

            if($.isNumeric(hobs.config.pacing_delay) && hobs.config.pacing_delay > 0) {
                testAction.options("pacingDelay", hobs.config.pacing_delay);
            }

            this.testcaseChain.addStep(testAction);
        }

        this.setStep(this.testcaseChain);

        $(this).trigger(hobs.TESTCASE_STARTED, [this]);

        return hobs.TestStep.prototype.exec.call(this, options);
    };

    // /**
    //  * @function hobs.TestCase#executionEndHandler
    //  *
    //  * @override
    //  **/
    // hobs.TestCase.prototype.executionEndHandler = function (data) {
    //     var testcase = this;
    //
    //     function alwaysHandler(res) {
    //         testcase.testcaseChain = null;
    //     }
    //
    //     this.dfr()
    //         .always(alwaysHandler);
    // };

    hobs.TestCase.prototype.initTestActions = function (doReturn) {
        var _self = this;

        function fctHandler() {
            var fctArgs = Array.prototype.slice.call(arguments),
                k = null,
                args = [];

            for (k in fctArgs) {
                if (k > 1) {
                    args.push(fctArgs[k]);
                }
            }

            this._tcSteps.push({
                action: fctArgs[0][fctArgs[1]],
                args: args
            });

            return this;
        }

        /**********************************************************************
         ADD PUBLIC/CHAINED FUNCTIONS to TestCase
         *********************************************************************/
        // Add core actions to TestCase itself
        // Allow call via testCase.click, testCase.navigateTo, ...
        var coreActions = hobs.actions.core;
        var key, key2, key3;

        for (key in coreActions) {
            _self[key] = fctHandler.bind(this, coreActions, key);
        }

        // Add Assertion actions to 'asserts' namespace
        // testCase.asserts.reset, ...
        var assAct = hobs.actions.assert;
        _self.asserts = {};

        for (key2 in assAct) {
            _self.asserts[key2] = fctHandler.bind(this, assAct, key2);
        }
        _self.assert = _self.asserts;

        // Add Configuration actions to 'config' namespace
        // testCase.config.changeContext, ...
        var confAct = hobs.actions.config;
        _self.config = {};

        for (key3 in confAct) {
            _self.config[key3] = fctHandler.bind(this, confAct, key3);
        }

        // Add registered Custom actions
        for (var i=0; i < hobs._customActions.length; i++) {
            var customAction = hobs._customActions[i],
                actions = customAction.actions;

            if (!_self[customAction.namespace]) {
                _self[customAction.namespace] = {};
            } else {
                // throw 'Custom action namespace '' + customAction.namespace + '' already exists, cannot register it!';
            }
            for (key in actions) {
                if (!actions.hasOwnProperty(key)) {
                    continue;
                }

                _self[customAction.namespace][key] = fctHandler.bind(this, actions, key);
            }
        }

        if (doReturn === true) {
            return _self;
        }
    };

    // function spawn(generatorFunc, options) {
    //     var tc = this;
    //     var execOptions = options;
    //
    //     function continuer(verb, arg1, arg2) {
    //         var result;
    //         try {
    //             result = generator[verb]();
    //         } catch (err) {
    //             return Promise.reject(err);
    //         }
    //
    //         if (result.done) {
    //             return result.value;
    //         } else {
    //             return result.value.exec(execOptions)
    //                         .always(function() {
    //                             // this === hobs action object
    //                             tc.testcaseChain.steps_.push(this);
    //                         }.bind(result.value))
    //                         .then(onFulfilled, onRejected);
    //         }
    //     }
    //     var generator = generatorFunc();
    //     var onFulfilled = continuer.bind(continuer, "next");
    //     var onRejected = continuer.bind(continuer, "throw");
    //     return onFulfilled(null, tc);
    // }

})(window.hobs, window.hobs.Chaining, window.hobs.teststeps.TestChain, $);


;

(function (hobs, Chaining, TestChain, $) {
    "use strict";

    /**
     * @class TestSuite
     * @extends hobs.TestStep
     * @param {string} name - The name of the test suite
     * @param {TestSuiteOptions} [options] - Extra options passed to the test suite
     *
     * @memberof hobs
     **/
    hobs.TestSuite = function (name, options, testsuiteFn) {
        var _options = $.extend({register: true}, options);
        var self = this;

        this._testCases = [];

        //var retryOptions = this.computeRetryOption(options);
        //var chainOptions = $.extend({logPrefix: '    ' }, retryOptions);

        //this.testsChain = new TestChain('testsChain - ' + hobs.utils.getIdFromString(name), 'testsChain - ' + name, chainOptions);

        hobs.TestStep.call(this, hobs.utils.getIdFromString(name), name, null /*this.testsChain*/, _options);

        if ($.isFunction(testsuiteFn)) {
            var winTcBkp = window.TestCase;

            window.TestCase = function() {
                var tc = new hobs.TestCase();
                hobs.TestCase.apply(tc, arguments);

                self.add(tc);

                return tc;
            };

            testsuiteFn.call(this);

            window.TestCase = winTcBkp;
        }

        if (name !== undefined && name !== null) {
            hobs.registerTestSuite(this);
        }

        return this;
    };

    hobs.TestSuite.prototype = new hobs.TestStep();

    // Constructor
    hobs.TestSuite.prototype.constructor = hobs.TestSuite;

    hobs.TestSuite.prototype.type = hobs.namespace + '.TestSuite';

    // Overwrite result messages
    hobs.TestSuite.prototype['res-msg-'+Chaining['Step']['STATE_PASSED']] = function () {
        return 'Testsuite [' + this.name + '] passed';
    };
    hobs.TestSuite.prototype['res-msg-'+Chaining['Step']['STATE_FAILED']] = function () {
        return 'Testsuite [' + this.name + '] failed';
    };

    hobs.TestSuite.prototype.getTestCases = function () {
        return this._testCases;
    };

    hobs.TestSuite.prototype.steps = function () {
        return this.testsChain;
    };

    /**
     * Returns a clone of the TestSuite
     * @function hobs.TestSuite#clone
     *
     * @returns {hobs.TestSuite}
     **/
    hobs.TestSuite.prototype.clone = function () {
        var clonedTS = jQuery.extend(true, new this.constructor(), this);
        var steps = clonedTS._testCases;
        for (var i=0; i<steps.length; i++) {
            steps[i] = steps[i].clone();
        }
        return clonedTS;
    };


    // hobs.TestSuite.prototype.getTestCases = function () {
    //     return this.testsChain.steps();
    // };

    hobs.TestSuite.prototype.exec = function (options) {
        // Reset test case result
        this._result = null;

        var testcase = (options && options.testcase) ? options.testcase : null;

        var retryOptions = this.computeRetryOptions(options);
        var chainOptions = $.extend({logPrefix: '    ' }, retryOptions);

        // Init Chain containing test cases
        this.testsChain = new TestChain('testsChain - ' + hobs.utils.getIdFromString(name), 'testsChain - ' + name, chainOptions);
        this.setStep(this.testsChain);

        // testcase passed as index from testsuite testcases list (1-index)
        if ($.isNumeric(testcase)) {
            this.testsChain.steps_.push.apply(this._testCases[testcase-1]);
        }
        else if (testcase !== null) {
            var tc = null,
                tcs = this.getTestCases();

            for (var i = 0; i < tcs.length; i++) {
                if (tcs[i].name === testcase) {
                    tc = tcs[i];
                    break;
                }
            }

            if (tc) {
                this.testsChain.steps_.push(tc);
            }
        }
        // No test case specified, execute them all
        else {
            this.testsChain.steps_.push.apply(this.testsChain.steps_, this._testCases);
        }

        if (this.options() && this.options().execInNewWindow) {
            this._originalWindowContext = hobs.context().loadEl;
            var winOptions = this.options().winOptions || hobs.config.default_win_options;
            this._newWindowContext = window.open("", "hobbesTest"+(new Date().getTime()), winOptions);
            hobs.setContext(this._newWindowContext);
        }

        $(this).trigger(hobs.TESTSUITE_STARTED, [this]);

        return hobs.TestStep.prototype.exec.call(this, options);
    };

    hobs.TestSuite.prototype.computeRetryOptions = function(options) {
        var retryOptions = {};
        var maxRetriesOnFailed = hobs.config.global_maxretries_on_failed;
        // check inherited options from parent call
        if (options && options.maxRetriesOnFailed !== undefined) {
            maxRetriesOnFailed = options.maxRetriesOnFailed;
        }
        // check local options
        if (this.options() && this.options().maxRetriesOnFailed !== undefined) {
            maxRetriesOnFailed = this.options().maxRetriesOnFailed;
        }
        // finally if maxRetriesOnFailed is higher than 0
        if (maxRetriesOnFailed > 0) {
            // if so, initialize the TestSuite testsChain with the _retryFailcount parameter
            retryOptions.execMode = TestChain.RETRY_ON_FAIL_CHAIN_EXEC_MODE;
            retryOptions.maxRetries = maxRetriesOnFailed;
        }
        return retryOptions;
    };

    /**
     * Add a test case to the test suite
     *
     * @param {(hobs.TestCase|hobs.TestSuite)} testcase - The test element to add to the test suite
     * @returns {hobs.TestSuite} Returns itself for chaining purpose
     **/
    hobs.TestSuite.prototype.addTestCase = function(testcase) {
        return this.add(testcase);
    };

    /**
     * Add a test "element" to the test suite
     *
     * @example <caption>Add a single test case to a test suite</caption>
     *
     * testsuite.add(testcase1)
     *
     * @example <caption>Add a single test suite to a test suite</caption>
     *
     * testsuite.add(testsuite1)
     *
     * @example <caption>Add multiple test elements to a test suite</caption>
     *
     * testsuite.add([testcase1, testcase2, testsuite1, testcase3])
     *
     * @param {(Array.<(hobs.TestCase|hobs.TestSuite)>|hobs.TestCase|hobs.TestSuite)} testElement - The test element to add to the test suite
     * @returns {hobs.TestSuite} Returns itself for chaining purpose
     **/
    hobs.TestSuite.prototype.add = function(testElement) {
        var _self = this;

        if (hobs.TestSuite.prototype.isPrototypeOf(testElement) || hobs.TestCase.prototype.isPrototypeOf(testElement)) {
            if (_self.options('each')) {
                $.each(['pacingDelay', 'delay', 'delayBefore', 'execBefore', 'before', 'execAfter', 'after', 'delayAfter', 'demoMode'], function(idx, option) {
                    if (_self.options('each')[option]) {
                        testElement.options(option, _self.options('each')[option]);
                    }
                });
            }

            _self._testCases.push(testElement);
        }
        else if ($.isArray(testElement)) {
            for (var i = 0; i < testElement.length; i++) {
                _self.add(testElement[i]);
            }
        }
        else {
            hobs.log('You can only add a hobs.TestCase or a hobs.TestSuite object');
        }

        return _self;
    };

    /**
     * @override
     **/
    hobs.TestSuite.prototype.result = function (format, withDetails, testcase) {
        if (format) {
            return hobs.reporters.format(this, format, withDetails);
        }

        if (this._result) {
            if (testcase && hobs.TestCase.prototype.isPrototypeOf(testcase)) {
                var res = $.extend({}, this._result),
                    tcRes = hobs.utils.objectFindByKey(res.steps, 'id', testcase.id);

                res.steps = [tcRes];

                return res;
            }
            else {
                return this._result;
            }
        }
        else {
            return this.computeResult();
        }
    };

    hobs.TestSuite.prototype.computeResult = function (testcase) {
        // var res = getResult.call(this, this._options);
        //
        // res.passed = this.testsChain.result().passed;
        // res.state = this.testsChain.result().state;
        //
        // res.steps = this.testsChain.result().steps;
        //
        // return res;
        var res = hobs.getResult.call(this, this._options),
            steps = [],//getTestCases(),
//            steps = this.testcaseChain ? this.testcaseChain.steps() : [],//getTestCases(),
            stepsResult = [];

        if (this.testChain() !== null) {
            steps = this.testChain().steps();
            res.passed = this.testChain().state() === Chaining.Step.STATE_PASSED;
            //res.state = this.testChain().state();
        }

        function getStepResultObj(dest, step) {
            var sRes = $.isFunction(step.result) ? step.result() : step.state();
            //sRes.options = step.options();

            dest.push(sRes);
        }

        function getSingleResult(index, tcChainStep) {
            if (!testcase || (testcase === tcChainStep)) {
                getStepResultObj(stepsResult, tcChainStep);
            }
        }

        for (var i=0; i < steps.length; i++) {
            var step = steps[i];

            if (step === this.testsChain) {
                $(step.steps()).each(getSingleResult);
            }
            else {
                getStepResultObj(stepsResult, step);
            }
        }

        res.steps = stepsResult;
        res.duration = this.duration();

        return res;
    };

    /**
     * @returns {boolean} Returns true if the test suite got executed and all the test cases have passed. Returns false if any of the test case failed
     **/
    hobs.TestSuite.prototype.hasPassed = function () {
        var testcases = this.getTestCases();
        for (var i = 0; i < testcases.length; i++) {
            if (testcases[i].state() !== Chaining.Step.STATE_PASSED) {
                return false;
            }
        }
        return true;
    };

    /**
     * @override
     **/
    hobs.TestSuite.prototype.cancel = function () {
        var _testsuite = this;

        function cancelParent() {
            hobs.TestStep.prototype.cancel.call(_testsuite);
        }

        $(this.testsChain).one(Chaining.Chain.CHAIN_EXECUTED, cancelParent);

        this.testsChain.cancel();
    };

    /**
     * @override
     **/
    hobs.TestSuite.prototype.done = function (state, res) {
        if (this._originalWindowContext && this._newWindowContext) {
            hobs.setContext(this._originalWindowContext);
            this._newWindowContext.close();
            this._originalWindowContext = undefined;
            this._newWindowContext = undefined;
        }

        this._result = this.computeResult();

        $(this).trigger(hobs.TESTSUITE_FINISHED, [this]);

        // hobs.TestStep.prototype.executionEndHandler.call(testcase, notification.result);

        hobs.TestStep.prototype.done.call(this, state, res);
    };

    /**
     * @override
     **/
    hobs.TestSuite.prototype.executionEndHandler = function () {
        var testsuite = this;

        function progressHandler(res) {
        }

        function alwaysHandler(res) {
            // if (testsuite._originalWindowContext && testsuite._newWindowContext) {
            //     hobs.setContext(testsuite._originalWindowContext);
            //     testsuite._newWindowContext.close();
            // }
            // testsuite._result = testsuite.computeResult();
            testsuite.testsChain = null;
            testsuite._testChain = null;
            testsuite._step = null;

            // hobs.TestStep.prototype.executionEndHandler.call(testsuite, res);

            // $(testsuite).trigger(hobs.TESTSUITE_FINISHED, [testsuite]);

        }

        this.dfr()
            .progress(progressHandler)
            .always(alwaysHandler);
    };

    /**
     * Append an array of test cases to the test suite
     *
     * @param {Array.<hobs.TestCase>} tests - The array of test cases to add to the test suite
     * @returns {hobs.TestSuite} Returns itself for chaining purpose
     **/
    hobs.TestSuite.prototype.addTestCases = function (tests) {
        for (var i = 0; i < tests.length; i++) {
            var test = tests[i];
            this.addTestCase(test);
        }

        return this;
    };

})(window.hobs, window.hobs.Chaining, window.hobs.teststeps.TestChain, $);


;

(function (hobs, Chaining, $) {



    var _context = null,
        _ctxObj = null;



    /**
     * Defines the test context, the window used to execute the tests.
     *
     * @see {@link hobs.context} to get the current test context
     *
     * @param {window|iframe} ctx - The window or iframe object where the tests will be executed
     **/
    hobs.setContext = function (ctx) {
        if (!$.isWindow(ctx)
            && (ctx.contentWindow === undefined || ctx.contentWindow === null)
            && (ctx.contentDocument === undefined || ctx.contentDocument === null)
        ) {
            throw new Error("Could not set test context");
        } else {
            _context = ctx;
        }
    };



    // /*
    //  * @deprecated Hobbes.js backward compatibility. Use {@link hobs.context}
    //  */
    Object.defineProperty(hobs, "window", {
        get: function() {
            // Handle jQuery.isWindow calls
            if (!arguments.callee.caller || (arguments.callee.caller.name !== 'isWindow' && arguments.callee.caller.toString().indexOf('obj.window') < 0)) {
                console.warn("@deprecated hobs.window is deprecated. Use hobs.context().window instead");
            }

            return hobs.context().window;
        }
    });



    /**
     * Returns the current test context, the window/iframe used to execute the tests
     *
     * @see {@link hobs.setContext} to learn how to set/change the context
     * @returns {object} An object containing context properties (window, document, loadEl)
     *
     * @property {object}      hobs.context()          - The context object.
     * @property {window}      hobs.context().window   - The test window object.
     * @property {document}    hobs.context().document - The document object of the test window.
     * @property {DOMElement}  hobs.context().loadEl   - The DOM Element embedding the test window (should be an iframe).
     *
     **/
    hobs.context = function () {
        try {
            // Current _context object is a reference to a window object
            if ($.isWindow(_context)) {
                _ctxObj = {
                    window: _context,
                    document: _context.document,
                    loadEl: _context
                };
            }
            // Current _context object is a DOM Element (most certainly an iframe)
            else {
                _ctxObj = {
                    window: _context.contentWindow,
                    document: _context.contentDocument,
                    loadEl: _context
                };
            }
        }
        catch(err) {
            hobs.log(err.stack);

            // Problem getting document/window objects, forcing them to null
            _ctxObj = {
                window: null,
                document: null,
                loadEl: _context
            };
        }

        return _ctxObj;
    };



})(window.hobs, window.hobs.Chaining, $);


;

(function (hobs, Chaining, $) {
    "use strict";



    /**
     * Look for a DOM element in the current [test window]{@link hobs.context}. Wraps a jQuery search
     *
     * @param {string} selector - {@link https://api.jquery.com/category/selectors/|jQuery selector} of the element to look for in the DOM of the {@link hobs.context|test window}
     * @param {Array|HTMLElement} [context=hobs.context().document] Array of selectors in hierarchical order determining root context where the search for the given element will take place (default hobs.context().document)
     * @returns {@link http://api.jquery.com/Types/#jQuery|jQuery} The list of elements found
     **/
    hobs.find = function (selector, context) {
        /* use hob's context by default */
        var thisContext = hobs.context().document;

        /* was context provided? */
        if (context) {
            /* context is a string selector or array or selectors */
            if ({ string: 1, array: 1 }[$.type(context)]) {
                var hierarchy = [].concat(context);

                /* find the right context */
                for (var x = 0; x < hierarchy.length; x++) {
                    thisContext = $(hierarchy[x], thisContext).contents();
                }
            } else {
                /* it was HTMLElement */
                thisContext = context;
            }
        }

        /* find element in desired context */
        return $(selector, thisContext);
    };



})(window.hobs, window.hobs.Chaining, $);


;

(function (hobs, $) {
    "use strict";



    /**
     * Makes the [test window/iframe]{@link hobs.context} navigate to the given url
     *
     * @param {string} url target URL (absolute or relative)
     * @param {object} [options=false] If set to true, it will only check url, otherwise it will do both, if object is an integer {hobs.NAVIGATE_CHECKONLY|hobs.NAVIGATE_SKIPCHECK}
     * accessibility via a HTTP *GET* request. The test window will **not** navigate
     *
     * @fires hobs#CONTEXT_NAVIGATION_LOAD
     * @fires hobs#CONTEXT_NAVIGATION_LOAD_ERROR
     **/
    hobs.navigate = function (url, options) {
        var pat = /^https?:\/\/|^\/\//i,
            skipCheck = false,
            checkOnly = false,
            loadCheckInterval = null,
            navTimeout = null,
            dfr = $.Deferred();

        if (!pat.test(url))
        {
            url = hobs.config.context_path + url;
        }

        if (options !== undefined) {
            if ($.type(options) === "boolean") {
                checkOnly = options;
            } else {
                // assume it's an object
                checkOnly = options.checkOnly || checkOnly;
                skipCheck = options.skipCheck || skipCheck;
            }
        }

        try {
            if (!skipCheck) {
                $.ajax({
                    url: url,
                    type: "GET",
                    timeout: hobs.config.navigation_timeout,
                    // url is accessible we can for the test window to navigate to it
                    success: successHandler,
                    // Problem accessing the url do not let the test window navigate to it,
                    // trigger navigation load error event
                    error: errorHandler,
                    // Code to run regardless of success or failure
                    // Handle head request timeout
                    complete: completeHandler
                });
            } else {
                successHandler();
            }
        }
        catch (e) {
            hobs.log("Cannot navigate to %s", url);
            hobs.log(e);
        }

        // Ajax check call succeeded
        function successHandler(data) {
            if (checkOnly === false) {
                if ($.isWindow(hobs.context().loadEl)) {
                    loadCheckInterval = setInterval(loadCheckIntervalHandler, 500);
                }
                else {
                    $(hobs.context().window).one('unload', navUnloadGlobalHandler);
                    $(hobs.context().loadEl).one('load', navLoadHandler);
                }

                hobs.context().window.location.href = url;
                navTimeout = setTimeout(navTimeoutHandler, hobs.config.navigation_timeout);
            }
            else {
                dfr.resolve(true, {'url': url, 'checkOnly': checkOnly});
            }
        }

        // Ajax check call failed
        function errorHandler(xhr, status, errorThrown) {
            $(hobs).trigger(hobs.CONTEXT_NAVIGATION_LOAD_ERROR , [xhr]);
            dfr.resolve(false, {'url': url, 'checkOnly': checkOnly, 'msg': 'HTTP Response: ' + xhr.status + ' - ' + xhr.statusText });
        }

        // Ajax check call timed out
        function completeHandler(xhr, status) {
            if (status === 'timeout') {
                $(hobs).trigger(hobs.CONTEXT_NAVIGATION_LOAD_ERROR , [xhr]);
                dfr.resolve(false, {'url': url, 'checkOnly': checkOnly, 'msg': 'HTTP Response: ' + xhr.status + ' - ' + xhr.statusText });
            }
        }

        function navLoadHandler() {
            // // Look for newly loaded page in loaded Web Structure
            // if (hobs.structure.current !== null) {
            //     hobs.structure.currentPage = hobs.utils.deepObjectSearch(hobs.structure.current, "url", url);
            // }
            clearTimeout(navTimeout);

            $(hobs).trigger(hobs.CONTEXT_NAVIGATION_LOAD);

            dfr.resolve(true, {'url': url, 'checkOnly': checkOnly});
        }

        function navTimeoutHandler() {
            if ($.isWindow(hobs.context().loadEl)) {
                clearInterval(loadCheckInterval);
            } else {
                // cancel "load" handler
                $(hobs.context().loadEl).off('load');
            }

            dfr.resolve(false, {'url': url, 'checkOnly': checkOnly, 'msg': 'Action timeout after ' + hobs.config.navigation_timeout+'ms.'});
        }

        function loadCheckIntervalHandler() {
            var perf = hobs.context().window.performance;
            if (perf && perf.timing && perf.timing.loadEventEnd && perf.timing.loadEventEnd > 0) {
                clearTimeout(navTimeout);
                clearInterval(loadCheckInterval);
                dfr.resolve(true, {'url': url, 'checkOnly': checkOnly});
            }
        }

        return dfr.promise();
    };

    function navUnloadGlobalHandler() {
        hobs.context().document.documentElement.innerHTML = '';
    }



})(window.hobs, $);


;

(function (hobs, Chaining, $) {
    "use strict";

    /**
     * Variables / Constants
     **/

    var _dynParams = {};



    /**
     * @returns {object} The dynamic parameters configured
     *
     * @ignore
     **/
    hobs.dynParams = function () {
        return _dynParams;
    };

    /**
     * @param {string} name - The name of the dynamic parameter to set/get
     * @param {*} [value] - If not null, the parameter of the given name will be set to this value. If null, The value of the given param will be returned
     **/
    hobs.param = function (name, value) {
        if (value !== undefined) {
            _dynParams[name] = value;

            return null;
        }
        else {
            return function hobs_get_param(opts) {
                if (opts && opts.params && opts.params.hasOwnProperty(name)) {
                    return opts.params[name];
                }
                else if (_dynParams.hasOwnProperty(name)) {
                    return _dynParams[name];
                }
                else {
                    return null;
                }
            };
        }
    };

    /**
     * Compute dynamic parameters in given object
     *
     * @param {function|object} obj - The object containing params to compute
     * @param {object} params - Object containing the dynamic parameters. See {@link hobs.param} to learn how to set dynamic parameters
     *
     * @ignore
     **/
    hobs.handleDynParameters = function (obj, params) {

        var copyObj = obj;

        // direct reference to hobs.getParam()
        if ($.isFunction(copyObj) && (copyObj.toString().indexOf('function hobs_get_param') === 0 || copyObj.toString().indexOf('function hobs_wel') === 0)) {
            copyObj = copyObj(params);
        }
        // A plain object that could contain references to hobs.getParam()
        else if ($.isPlainObject(copyObj)) {
            copyObj = $.extend(true, {}, obj);
            var eachHandler = function (key, value) {
                if ($.isFunction(value) && value.toString().indexOf('function hobs_get_param') === 0) {
                    copyObj[key] = value(params);
                }
                else if ($.isPlainObject(value)) {
                    copyObj[key] = hobs.handleDynParameters(value, params);
                }
                else if($.type(value) === 'string' && value.match(/\%\w+\%/)) {
                    var matches = value.match(/\%\w+\%/g);

                    for (var i=0; i < matches.length; i++) {
                        var match = matches[i].replace(/\%/g, "");
                        var param = hobs.param(match)(params);

                        if (param !== null) {
                             copyObj[key] = value.replace(matches[i], param);
                        }
                    }
                }
            };

            $.each( copyObj, eachHandler);
        }
        // A string that contains variable(s) to evaluate
        else if($.type(copyObj) === 'string' && copyObj.match(/\%\w+\%/)) {
            var matches = copyObj.match(/\%\w+\%/g);

            for (var i=0; i < matches.length; i++) {
                var match = matches[i].replace(/\%/g, "");
                var param = hobs.param(match)(params);

                if (param !== null) {
                    copyObj = copyObj.replace(matches[i], param);
                }
            }
        }

        return copyObj;
    };



})(window.hobs, window.hobs.Chaining, $);


;

(function (hobs, Chaining, $) {
    "use strict";



    /**
     * Variables / Constants
     **/

    /**
     * @ignore
     */
    hobs._currentRun = null;
    hobs._lastExecutionResult = [];



    /**
     * Cancel current global test run execution
     *
     * @see {@link hobs.runTest}
     *
     **/
    hobs.cancelRun = function () {
        if (!hobs._currentRun) {
            return -1;
        }

        hobs._currentRun.cancel();
    };

    /**
     * Execute registered tests.
     *
     * @example <caption>Execute all test cases of all test suites</caption>
     *
     * hobs.runTest()
     * // or
     * hobs.runTest(null, null)
     *
     * @example <caption>Execute all tests of a specific test suite (first test suite that is found with that name)</caption>
     *
     * hobs.runTest('testsuite name')
     *
     * @example <caption>Execute a specific test of a specific test suite</caption>
     *
     * hobs.runTest('testsuite name', 'testcase name')
     *
     * @example <caption>Execute tests using metadata filter include option</caption>
     *
     * // Assuming you have a TestSuite that contains following TestCase:
     * new hobs.TestCase("tc1", { metadata: { "flaky": true }})
     * // The metadata object can be used later to filter the tests to be run
     * 
     * hobs.runTest(null, null, {
     *  "withMetadata": {
     *   "flaky": {
     *     "value": false, 
     *     "type": "include"
     *   }
     *  }
     * })
     *
     * @example <caption>Execute tests using metadata filter exclude option</caption>
     *
     * // Similarly to the previous example, it can be excluded using exclude type.
     * 
     * hobs.runTest(null, null, {
     *  "withMetadata": {
     *   "flaky": {
     *     "value": true, 
     *     "type": "exclude"
     *   }
     *  }
     * })
     * 
     * @example <caption>Resume tests execution option</caption>
     *
     * // In some cases, resuming tests execution from a specific point can help (i.e after a browser crash etc..)
     * // Based on the same logic as for path filter option, the resume option uses the test path.
     * 
     * hobs.runTest(null, null, { resumePath: "/a/b/c" })
     * 
     * // As a result test execution will start right after the /a/b/c test.
     * 
     * @example <caption>Execute tests using path filter option</caption>
     *
     * // Assuming you have a large set of TestSuites that contains sub TestSuites which contains TestCases.
     * // If you need to run only a specific set of TestCases that belong to different sub TestSuites,
     * // the path filter will help.
     * // Following is an example of 2 level TestSuites:
     * 
     * var ts1 = new hobs.TestSuite("ts#1");
     * ts1.add(new hobs.TestCase("tc#1"));
     * ts1.add(new hobs.TestCase("tc#2"));
     * ts1.add(new hobs.TestCase("tc#3"));
     * 
     * // inner testsuite
     * var ts2 = new hobs.TestSuite("ts#2");
     * ts2.add(new hobs.TestCase("tc#4"));
     * ts2.add(new hobs.TestCase("tc#5"));
     * ts2.add(new hobs.TestCase("tc#6"));
     * ts1.add(ts2);
     * 
     * hobs.runTest(null, null, {
     *     "withPaths": [
     *         {
     *             "path": "/ts1/tc1", 
     *             "type": "include"
     *         },
     *         {
     *             "path": "/ts1/tc3", 
     *             "type": "include"
     *         },
     *         {
     *             "path": "/ts1/ts2", 
     *             "type": "include"
     *         },
     *         {
     *             "path": "/ts1/ts2/tc5", 
     *             "type": "exclude"
     *         }
     *     ]
     * })
     * 
     * // As a result only TC#1, TC#3, TC#4, and TC#6 are executed.
     * 
     * @param {string} [testSuite] - Name or UUID of the test suite to execute
     * @param {string} [testCase] - Name or UUID of the test case to execute
     * @param {object} [options] - Extra options passed to the execution
     **/
    hobs.runTest = function (testSuite, testCase, options) {
        options = $.extend({}, options);

        initTestRun();

        var ts, tsId, tc, tcId,
            tsEvents = [hobs.TESTSUITE_STARTED, hobs.TESTSUITE_FINISHED].join(" "),
            tcEvents = [hobs.TESTCASE_STARTED, hobs.TESTCASE_FINISHED].join(" "),
            orderedTS = hobs.getRegisteredTestSuites().sort(function(a, b){
                if(a.name < b.name) {
                    return -1;
                }
                if(a.name > b.name) {
                    return 1;
                }
                return 0;
            });
        
        // Try to first find this testsuite based on the uuid
        ts = hobs.utils.objectFindByKey(hobs.getTestSuites(), 'uuid', testSuite);
        if (!ts) {
            // Fallback to find from name / id property
            tsId = hobs.utils.getIdFromString(testSuite);
            ts = hobs.utils.objectFindByKey(hobs.getTestSuites(), 'id', tsId);
        }

        if (ts && testCase) {
            // Try to first find this testcase based on the uuid
            tc = hobs.utils.objectFindByKey(ts.getTestCases(), 'uuid', testCase);
            if (!tc) {
                tcId = hobs.utils.getIdFromString(testCase);
                tc = hobs.utils.objectFindByKey(ts.getTestCases(), 'id', tcId);
            }

            if (ts && tc) {
                //ts.options("testcase", tc.name);
                   //hobs._currentRun.addStep(ts);
                   options.testcase = tc.name;
                   hobs._currentRun = ts.clone();
            }
        }
        else if (ts) {
               hobs._currentRun.addStep(ts.clone());
        }
        else if (testSuite && !ts) {
            return null;
        } else {
            for (var i=0; i < orderedTS.length; i++) {
                var rTestSuite = orderedTS[i];
                var clonedTS = rTestSuite.clone();
                if (options.withPaths !== undefined) {
                    hobs.utils.pathFilter(clonedTS, options.withPaths);
                    if (clonedTS.getTestCases().length === 0) {
                        clonedTS = null; // no need to keep filtered TestSuite that are empty.
                    }
                }
                if (clonedTS !== null && options.withMetadata !== undefined) {
                    hobs.utils.metadataFilter(clonedTS, options.withMetadata);
                    if (clonedTS.getTestCases().length === 0) {
                        clonedTS = null; // no need to keep filtered TestSuite that are empty.
                    }
                }
                if (clonedTS !== null) {
                    hobs._currentRun.addStep(clonedTS);
                }
            }
        }

        if (options.resumePath !== undefined) {
            hobs.utils.resumeFilter(hobs._currentRun.steps(), options.resumePath);
        }

        if (options.dryRun && options.dryRun === true) {
            $(hobs).trigger(hobs.RUN_FINISHED);
            return;
        }

        function testElementEvtHandler(testElement) {
            function handler(evt) {
                $(hobs).trigger(evt, [testElement]);
            }

            return handler;
        }

        function setGenericListeners(testElements, remove) {

            for (var j=0; j < testElements.length; j++) {
                var testElement = testElements[j];

                if (hobs.TestCase.prototype.isPrototypeOf(testElement)) {
                    if (remove) {
                        $(testElement).off(tcEvents);
                    }
                    else {
                        $(testElement).on(tcEvents, testElementEvtHandler(testElement));
                    }
                }
                else if (hobs.TestSuite.prototype.isPrototypeOf(testElement)) {
                    if (remove) {
                        $(testElement).off(tsEvents);
                    }
                    else {
                        $(testElement).on(tsEvents, testElementEvtHandler(testElement));
                    }

                    setGenericListeners(testElement.getTestCases(), remove);
                }
            }
        }

        function applyGenericListeners(remove) {
            if (hobs.TestSuite.prototype.isPrototypeOf(hobs._currentRun)) {
                setGenericListeners(hobs._currentRun.getTestCases(), remove);
            }
            else {
                setGenericListeners(hobs._currentRun.steps(), remove);
            }
        }

        applyGenericListeners();
        handleRunStart();

        hobs._currentRun
            .exec(options)
            .then(function() {
                applyGenericListeners(true);
                handleRunFinished();
            });
    };

    hobs.currentRun = function () {
        return hobs._currentRun;
    };

    /**
     * @returns {object} The result object of the last call of {@link hobs.runTest}
     **/
    hobs.result = function () {
        return hobs._lastExecutionResult;
    };



    function initTestRun() {
        hobs._lastExecutionResult = [];
        hobs._currentRun = new Chaining.Chain();
    }

    function handleRunStart() {
        $(hobs).trigger(hobs.RUN_STARTED, [hobs._currentRun]);
    }

    function handleRunFinished() {
        function endRunHandler() {
            var chain = hobs._currentRun;

            if (hobs.TestSuite.prototype.isPrototypeOf(chain)) {
                hobs._lastExecutionResult.push(chain.result());
            }
            else if (chain !== null) {
                for (var i = 0; i < chain.steps().length; i++) {
                    hobs._lastExecutionResult.push(chain.steps()[i].result());
                }
            }

           hobs._currentRun = null;

            $(hobs).trigger(hobs.RUN_FINISHED);
        }

        setTimeout(endRunHandler, 50);
    }



})(window.hobs, window.hobs.Chaining, $);


;

(function(hobs, $) {
    "use strict";

    /**
     * Main namespace
     * @namespace hobs.actions
     */
    hobs.actions = hobs.actions || {};

    hobs.actions.DEMO_MODE_DEFAULT_DELAY = 1250;



    /**
     * @member
     * Private Functions
     **/
    hobs.actions.jQSelectorPollCheckTestStepTimeoutFct = function(opts, dfr) {
        // var selDyn = hobs.handleDynParameters(this.selector, opts);
        //
        // this.execData('args', [selDyn, opts]);
        this.execData('msg', '${element:0} not found in the DOM!');
        dfr.notify({
            type: hobs.Chaining.Step.STATE_COMPLETED,
            state: hobs.Chaining.Step.STATE_FAILED
        });
    };

    hobs.actions.handleDemoMode = function(stepOptions, selector, color, text, options) {
        if (this.options('demoMode') === true) {
            var el = hobs.utils.highlightElement(selector, color, text, options);
            this.setDemoModeHighlightDOMEl(el);
        }
    };



})(window.hobs, $);


;

(function(hobs, $) {
    "use strict";

    /**
     * @namespace
     *
     * @desc Generic Assertions
     *
     * **These classes are added to {@link hobs.TestCase} under `.assert` namespace to make them available as follow:**
     *
     * <pre>new hobs.TestCase()
     *                <span style="color:blue;">.assert.isTrue(...)
     *                 .assert.location(...)</span>
     *                (...)
     *                <span style="color:blue;">.asserts.exists(...)</span></pre>
     *
     */
    hobs.actions.assert = {};

    hobs.actions.assert.namespace = "hobs.actions.assert";

}(window.hobs, $));


;

(function(hobs, $) {
    "use strict";

    /**
     * @class
     *
     * Checks if DOM Elements have (or not) specific CSS class
     *
     * @param {String} selector jQuery selector for the DOM Elements to check
     * @param {String} cssAttr the css attribute name to check
     * @param {String} cssValue the value of the css attribute
     * @param {boolean} [isTrue=true] Checks if css attribute is as expected or not
     * @param {TestActionOptions} [options] Test method options
     */
    hobs.actions.assert.css = function(selector, cssAttr, cssValue, isTrue, options) {
        this.selector = selector;
        this.cssAttr = cssAttr;
        this.cssValue = cssValue;
        this.isTrue = (isTrue !== undefined && isTrue !== null) ? isTrue : true;

        var _assertion = this,
            selector_dyn = null,
            cssAttr_dyn = null,
            cssValue_dyn = null,
            isTrue_dyn = null,

        _beforeCheckFct = function(opts) {
            // Process dynamic parameters
            selector_dyn = hobs.handleDynParameters(_assertion.selector, opts);
            cssAttr_dyn = hobs.handleDynParameters(_assertion.cssAttr, opts);
            cssValue_dyn = hobs.handleDynParameters(_assertion.cssValue, opts);
            isTrue_dyn = hobs.handleDynParameters(_assertion.isTrue, opts);

            _assertion.execData('args', [selector_dyn, (isTrue_dyn ? "" : "not"), cssAttr_dyn, cssValue_dyn, null, options]);
        },

        _checkFct = function(opts) {
            // Process dynamic parameters
            var $el = hobs.utils.dom.getJQElFromSelector(_assertion.execData('args')[0], opts);
            _assertion.execData('element', $el);

            return (
                $el.length > 0
                && (( $el.css(cssAttr_dyn) === cssValue_dyn ) === isTrue_dyn)
            );
        },

        _checkTrueFct = function(opts, dfr) {
            _assertion.execData('args', [selector_dyn, (isTrue_dyn ? "" : "not"), cssAttr_dyn, cssValue_dyn, _assertion.execData('element').css(cssAttr_dyn), options]);

            this.done(hobs.Chaining.Step.STATE_PASSED);
        },

        _timeoutFct = function(opts, dfr) {
            if (_assertion.execData('element').length === 0) {
                _assertion.execData('msg', '${element:0} not found in the DOM!');
            }
            else {
                _assertion.execData('args', [selector_dyn, (isTrue_dyn ? "" : "not"), cssAttr_dyn, cssValue_dyn, _assertion.execData('element').css(cssAttr_dyn), options]);
            }

            this.done(hobs.Chaining.Step.STATE_FAILED);
        },

        _options = $.extend({}, options, {
            beforeCheckFct: _beforeCheckFct,
            checkTrueFct: _checkTrueFct,
            timeoutFct: _timeoutFct,
            demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY
        });

        hobs.teststeps.PollCheckTestStep.call(this, null, null, _checkFct, _options);
    };

    hobs.utils.definePrototype(
        hobs.actions.assert.css,
        hobs.teststeps.PollCheckTestStep,
        {
            'type' : hobs.actions.assert.namespace + ".cssAttribute",
            'res-msg-passed' : 'Asserted ${element:0} css ${attribute:2} has ${1} ${value:3}',
            'res-msg-failed' : 'Not asserted ${element:0} css ${attribute:2} has ${1} ${value:3} (${actual value:4})'
        }
    );

    // Alias
    hobs.actions.assert.cssAttribute = hobs.actions.assert.css;

}(window.hobs, $));


;

(function(hobs, $) {
    "use strict";

    /**
     * @class
     *
     * Checks if DOM Elements have (or not) specific CSS class
     *
     * @param {String} selector jQuery selector for the DOM Elements to check
     * @param {String} cssClass the class existence to check
     * @param {boolean} [hasClass=true] Checks if class is present or not
     * @param {TestActionOptions} [options] Test method options
     */
    hobs.actions.assert.cssClass = function(selector, cssClass, hasClass, options) {
        this.selector = selector;
        this.cssClass = cssClass;
        this.hasClass = (hasClass !== undefined && hasClass !== null) ? hasClass : true;

        var _assertion = this,
            selector_dyn = null,
            cssClass_dyn = null,
            hasClass_dyn = null,

        _beforeCheckFct = function(opts) {
            // Process dynamic parameters
            selector_dyn = hobs.handleDynParameters(_assertion.selector, opts),
            cssClass_dyn = hobs.handleDynParameters(_assertion.cssClass, opts),
            hasClass_dyn = hobs.handleDynParameters(_assertion.hasClass, opts);

            _assertion.execData('args', [selector_dyn, (hasClass_dyn ? "" : "not"), cssClass_dyn, null, options]);

            // Handle Demo Mode
           hobs.actions.handleDemoMode.call(_assertion, opts, selector_dyn, 'blue', 'Asserting if has ' + (hasClass_dyn ? '' : 'NOT ') + 'CSS class ' + cssClass_dyn);
        },

        _checkFct = function(opts) {
            var $el = hobs.utils.dom.getJQElFromSelector(_assertion.execData('args')[0], opts);
            _assertion.execData('element', $el);

            return (
                $el.length > 0
                && ($el.hasClass(cssClass_dyn)) === hasClass_dyn
            );
        },

        _checkTrueFct = function(opts, dfr) {
            _assertion.execData('args', [selector_dyn, (hasClass_dyn ? "" : "not"), cssClass_dyn, _assertion.execData('element').attr('class'), options]);

            this.done(hobs.Chaining.Step.STATE_PASSED);
        },

        _timeoutFct = function(opts, dfr) {
            if (_assertion.execData('element').length === 0) {
                _assertion.execData('msg', '${element:0} not found in the DOM!');
            }
            else {
                _assertion.execData('args', [selector_dyn, (hasClass_dyn ? "" : "not"), cssClass_dyn, _assertion.execData('element').attr('class'), options]);
            }

            this.done(hobs.Chaining.Step.STATE_FAILED);
        },

        _options = $.extend({}, options, {
            beforeCheckFct: _beforeCheckFct,
            checkTrueFct: _checkTrueFct,
            timeoutFct: _timeoutFct,
            demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY
        });

        hobs.teststeps.PollCheckTestStep.call(this, null, null, _checkFct, _options);
    };

    hobs.utils.definePrototype(
        hobs.actions.assert.cssClass,
        hobs.teststeps.PollCheckTestStep,
        {
            'type' : hobs.actions.assert.namespace + ".hasCssClass",
            'res-msg-passed' : 'Asserted ${element:0} has ${1} ${css class:2}',
            'res-msg-failed' : 'Not asserted ${element:0} has ${1} ${css class:2} (${actual value:3})'
        }
    );

    // Alias
    hobs.actions.assert.hasCssClass = hobs.actions.assert.cssClass;

}(window.hobs, $));


;

(function(hobs, $) {
    "use strict";

    /**
     * @class
     *
     * Checks if 2 elements are strictly equals (element1 === element2)
     *
     * @param {*} element1 The first element to be verified
     * @param {*} element2 The second element to be verified
     * @param {boolean} [isEqual=true] Check equal or inequal condition
     *
     * @param {TestActionOptions} [options] Test method options
     */
    hobs.actions.assert.equal = function(element1, element2, isEqual, options) {
        var _assertion = this;

        _assertion.element1 = element1;
        _assertion.element2 = element2;
        _assertion.isEqual = (isEqual !== undefined && isEqual !== null) ? isEqual : true;

        var element1_dyn = null,
            element2_dyn = null,
            isEqual_dyn = null,

            _checkFct = function(opts) {
                return (element1_dyn === element2_dyn) === isEqual_dyn;
            },

            _beforeCheckFct = function(opts) {
                // Process dynamic parameters
                element1_dyn = hobs.handleDynParameters(_assertion.element1, opts);
                element2_dyn = hobs.handleDynParameters(_assertion.element2, opts);
                isEqual_dyn = hobs.handleDynParameters(_assertion.isEqual, opts);

                _assertion.execData('args', [element1_dyn, element2_dyn, (isEqual_dyn ? "" : "not"), options]);

                // Handle Demo Mode
               hobs.actions.handleDemoMode.call(_assertion, opts, null, 'blue', 'Asserting if 2 elements are strictly equal', {type: 'CENTER_BOX'});
            },

            _checkTrueFct = function(opts) {
                this.done(hobs.Chaining.Step.STATE_PASSED);
            },

            _timeoutFct = function(opts, dfr) {
                this.done(hobs.Chaining.Step.STATE_FAILED);
            },

            _options = $.extend({}, options, {
                checkTrueFct: _checkTrueFct,
                beforeCheckFct: _beforeCheckFct,
                timeoutFct: _timeoutFct,
                demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY
            });

        hobs.teststeps.PollCheckTestStep.call(this, null, null, _checkFct, _options);
    };

    hobs.utils.definePrototype(
        hobs.actions.assert.equal,
        hobs.teststeps.PollCheckTestStep,
        {
            'type' : hobs.actions.assert.namespace + ".equal",
            'res-msg-passed' : 'Asserted ${element 1:0} does ${2} equal ${element 2:1}',
            'res-msg-failed' : 'Not asserted ${element 1:0} does ${2} equal ${element 2:1}'
        }
    );

}(window.hobs, $));


;

(function(hobs, $) {
    "use strict";

    /**
     * @class
     *
     * Checks if an element exists in the DOM, every delay, until timeout
     *
     * @param {String} selector jQuery selector for the DOM Element to check
     * @param {boolean} [exists=true] Checks present or absent status
     * @param {TestActionOptions} [options] Test method options
     */
    hobs.actions.assert.exist = function(selector, exists, options) {
        this.selector = selector;
        this.doesExist = (exists !== undefined && exists !== null) ? exists : true;

        var _assertion = this,
            // selector_dyn = null,
            exists_dyn = null,

        _beforeCheckFct = function(opts) {
            // Process dynamic parameters
            var selector_dyn = hobs.handleDynParameters(_assertion.selector, opts);
            exists_dyn = hobs.handleDynParameters(_assertion.doesExist, opts);

            _assertion.execData('args', [selector_dyn, (exists_dyn ? "" : "not"), options]);

            // Handle Demo Mode
           hobs.actions.handleDemoMode.call(_assertion, opts, selector_dyn, 'blue', 'Asserting if ' + (exists_dyn ? '' : 'NOT ') + 'exists', {type: 'CENTER_BOX'});
        },

        _checkFct = function(opts) {
            var retries = 0;
            var $el = hobs.utils.dom.getJQElFromSelector(_assertion.execData('args')[0], opts);
            _assertion.execData('element', $el);

            do {
                try {
                    return ($el.length > 0) === exists_dyn;
                } catch(e) {
                    // ignore errors
                }
            } while (retries++ < hobs.config.ie11_maxretries);
            return false;
         },

        _checkTrueFct = function(opts, dfr) {
            this.done(hobs.Chaining.Step.STATE_PASSED);
        },

        _timeoutFct = function(opts, dfr) {
            if (_assertion.execData('element').length === 0) {
                _assertion.execData('msg', '${element:0} not found in the DOM!');
            }
            this.done(hobs.Chaining.Step.STATE_FAILED);
        },

        _options = $.extend({}, options, {
            beforeCheckFct: _beforeCheckFct,
            checkTrueFct: _checkTrueFct,
            timeoutFct: _timeoutFct,
            demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY});

        hobs.teststeps.PollCheckTestStep.call(this, null, null, _checkFct, _options);
    };

    hobs.utils.definePrototype(
        hobs.actions.assert.exist,
        hobs.teststeps.PollCheckTestStep,
        {
            'type' : hobs.actions.assert.namespace + ".exists",
            'res-msg-passed' : 'Asserted ${element:0} does ${1} exist',
            'res-msg-failed' : 'Not asserted ${element:0} does ${1} exist'
        }
    );

    // Alias
    hobs.actions.assert.exists = hobs.actions.assert.exist;

}(window.hobs, $));


;

(function(hobs, $) {
    "use strict";

    /**
     * @class
     *
     * Checks if a function returns false, every delay, until timeout
     *
     * @param {boolean|function} isFalse The expression that will be evaluate to false. A boolean or a function which returns a boolean
     * @param {TestActionOptions} [options] Test method options
     */
    hobs.actions.assert.isFalse = function(isFalse, options) {
        var _assertion = this;

        _assertion.isFalse = isFalse;

        var _checkFct = null;

        if ($.isFunction(_assertion.isFalse)) {
            _checkFct = function(opts) {
                // Process dynamic parameters
                var isFalse_dyn = hobs.handleDynParameters(_assertion.isFalse, opts);

                if ($.isFunction(isFalse_dyn)) {
                    return isFalse_dyn(opts) === false;
                }
                else {
                    return isFalse_dyn === false;
                }
            };
        }
        else {
            _checkFct = function(opts) {
                // Process dynamic parameters
                var isFalse_dyn = hobs.handleDynParameters(_assertion.isFalse, opts);

                return isFalse_dyn === false;
            };
        }

        var _beforeCheckFct = function(opts) {
            // Handle Demo Mode
           hobs.actions.handleDemoMode.call(_assertion, opts, null, 'blue', 'Asserting if something is false', {type: 'CENTER_BOX'});
        },

        _checkTrueFct = function(opts) {
            _assertion.execData('args', [_assertion.isFalse, options]);
            this.done(hobs.Chaining.Step.STATE_PASSED);
        },

        _timeoutFct = function(opts, dfr) {
            _assertion.execData('args', [_assertion.isFalse, options]);
            this.done(hobs.Chaining.Step.STATE_FAILED);
        },

        _options = $.extend({}, options, {timeoutFct: _timeoutFct, checkTrueFct: _checkTrueFct, beforeCheckFct: _beforeCheckFct, demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY});

        hobs.teststeps.PollCheckTestStep.call(_assertion, null, null, _checkFct, _options);
    };

    hobs.utils.definePrototype(
        hobs.actions.assert.isFalse,
        hobs.teststeps.PollCheckTestStep,
        {
            'type' : hobs.actions.assert.namespace + ".isFalse",
            'res-msg-passed' : 'Asserted ${element:0} is false',
            'res-msg-failed' : 'Not asserted ${element:0} is false'
        }
    );

}(window.hobs, $));


;

(function(hobs, $) {
    "use strict";

    /**
     * @class
     *
     * Checks if the element(s) specified by the selector is in the viewport or not.
     *
     * @param  {String}  selector            The selector to the element(s)
     * @param  {Boolean} [isInViewport=true] `true` to check if it is, `false` to check if it isn't
     * @param  {TestActionOptions}     [options]           Options for the test step
     */
    hobs.actions.assert.inViewport = function(selector, isInViewport, options) {
        var _assertion = this;

        this.selector = selector;
        this.isInViewport = isInViewport !== undefined ? isInViewport : true;

        var selector_dyn = null,
            isInViewport_dyn = null,

        _beforeCheckFct = function(opts) {
            // Process dynamic parameters
            selector_dyn = hobs.handleDynParameters(_assertion.selector, opts);
            isInViewport_dyn = hobs.handleDynParameters(_assertion.isInViewport, opts);

            _assertion.execData('args', [selector_dyn, (isInViewport_dyn ? "" : "not"), null, options]);
        },

        _checkFct = function(opts) {
            var $el = hobs.utils.dom.getJQElFromSelector(selector_dyn, opts);
            _assertion.execData('element', $el);

            // Check if the elements are inside the viewport
            if (isInViewport_dyn) {
                return $el.length > 0 && Array.prototype.reduce.call($el.map(
                    function() {
                        var rect = this.getBoundingClientRect();
                        return rect.left >= 0
                            && rect.right <= $(hobs.context().window).width()
                            && rect.top >= 0
                            && rect.bottom <= $(hobs.context().window).height();
                    }),
                    function(allVisible, thisVisible) {
                        return allVisible && thisVisible;
                    },
                    true);
            }

            // Check if the elements are outside the viewport
            return $el.length === 0 || Array.prototype.reduce.call($el.map(
                function() {
                    var rect = this.getBoundingClientRect();
                    return rect.left >= $(hobs.context().window).width()
                        || rect.right <= 0
                        || rect.top >= $(hobs.context().window).height()
                        || rect.bottom <= 0;
                }),
                function(allHidden, thisHidden) {
                    return allHidden && thisHidden;
                },
                true);
        },

        _checkTrueFct = function(opts, dfr) {
            this.done(hobs.Chaining.Step.STATE_PASSED);
        },

        _timeoutFct = function(opts, dfr) {
            if (_assertion.execData('element').length === 0) {
                _assertion.execData('msg', '${element:0} not found in the DOM!');
            }
            else {
                _assertion.execData('args', [selector_dyn, (isInViewport_dyn ? "" : "not"), _assertion.execData('element').offset(), options]);
            }

            this.done(hobs.Chaining.Step.STATE_FAILED);
        },

        _options = $.extend({}, options, {
            beforeCheckFct: _beforeCheckFct,
            checkTrueFct: _checkTrueFct,
            timeoutFct: _timeoutFct,
            demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY
        });

        hobs.teststeps.PollCheckTestStep.call(this, null, null, _checkFct, _options);
    };

    hobs.utils.definePrototype(
        hobs.actions.assert.inViewport,
        hobs.teststeps.PollCheckTestStep,
        {
            'type' : hobs.actions.assert.namespace + ".inViewport",
            'res-msg-passed' : 'Asserted ${element:0} is ${1} in viewport',
            'res-msg-failed' : 'Not asserted ${element:0} is ${1} in viewport (${Element offset:2})'
        }
    );

    // Alias
    hobs.actions.assert.isInViewport = hobs.actions.assert.inViewport;

}(window.hobs, $));


;

(function(hobs, $) {
    "use strict";

    /**
     * @class
     *
     * Checks if a DOM element is considered "enabled" by checking existence of "disabled" attribute set to "disabled", every delay, until timeout
     *
     * @param {String} selector jQuery selector for the DOM Element to check
     * @param {boolean} [isEnabled=true] Check enable or disable status of the element
     * @param {TestActionOptions} [options] Test method options
     */
    hobs.actions.assert.isEnabled = function(selector, isEnabled, options) {
        var _assertion = this,
            selector_dyn,
            isEnabled_dyn;

        _assertion.selector = selector;
        _assertion.isEnabled = (isEnabled !== undefined && isEnabled !== null) ? isEnabled : true;

        var _beforeCheckFct = function(opts) {
            // Process dynamic parameters
            selector_dyn = hobs.handleDynParameters(_assertion.selector, opts);
            isEnabled_dyn = hobs.handleDynParameters(_assertion.isEnabled, opts);

            _assertion.execData('args', [selector_dyn, (isEnabled_dyn ? "" : "not"), options]);

            // Handle Demo Mode
           hobs.actions.handleDemoMode.call(_assertion, opts, selector_dyn, 'blue', 'Asserting if ' + (isEnabled_dyn ? '' : 'NOT ') + 'enabled', {type: 'CENTER_BOX'});
        },

        _checkFct = function(opts) {
            // Process dynamic parameters
            // var selector_dyn = hobs.handleDynParameters(_assertion.selector, opts),
            //     isEnabled_dyn = hobs.handleDynParameters(_assertion.isEnabled, opts);

            var $el = hobs.utils.dom.getJQElFromSelector(_assertion.execData('args')[0], opts);
            _assertion.execData('element', $el);

            return (
                $el.length > 0
                && ($el.attr('disabled') !== undefined) !== isEnabled_dyn
            );
        },

        _checkTrueFct = function(opts) {
            this.done(hobs.Chaining.Step.STATE_PASSED);
        },

        _timeoutFct = function(opts, dfr) {
            if (_assertion.execData('element').length === 0) {
                _assertion.execData('msg', '${element:0} not found in the DOM!');
            }
            this.done(hobs.Chaining.Step.STATE_FAILED);
        },

        _options = $.extend({}, options, {
            checkTrueFct: _checkTrueFct,
            beforeCheckFct: _beforeCheckFct,
            timeoutFct: _timeoutFct,
            demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY});

        hobs.teststeps.PollCheckTestStep.call(_assertion, null, null, _checkFct, _options);
    };

    hobs.utils.definePrototype(
        hobs.actions.assert.isEnabled,
        hobs.teststeps.PollCheckTestStep,
        {
            'type' : hobs.actions.assert.namespace + ".isEnabled",
            'res-msg-passed' : 'Asserted ${element:0} is ${1} enabled',
            'res-msg-failed' : 'Not asserted ${element:0} is ${1} enabled'
        }
    );

    // Alias
    hobs.actions.assert.enabled = hobs.actions.assert.isEnabled;

}(window.hobs, $));


;

(function(hobs, $) {
    "use strict";

    /**
     * @class
     *
     * Checks the pathname of the current URL (window.location.pathname)
     *
     * @param {String} url The expected pathname
     * @param {boolean} [isTrue=true] Controls behaviour of the assertion
     * @param {TestActionOptions} [options] Test method options
     */
    hobs.actions.assert.location = function(url, isTrue, options) {
        this.url = url;
        this.isTrue = (isTrue !== undefined && isTrue !== null) ? isTrue : true;

        var _assertion = this,
            url_dyn = null,
            isTrue_dyn = null,

        _beforeCheckFct = function(opts) {
            // Process dynamic parameters
            url_dyn = hobs.config.context_path + hobs.handleDynParameters(_assertion.url, opts);
            isTrue_dyn = hobs.handleDynParameters(_assertion.isTrue, opts);

            _assertion.execData('args', [url_dyn, (isTrue_dyn ? "" : "not"), hobs.context().window.location.pathname, options]);

            // Handle Demo Mode
           hobs.actions.handleDemoMode.call(_assertion, opts, url_dyn, 'blue', 'Asserting if current location is ' + (isTrue_dyn ? '' : 'NOT ') + 'the expected one', {type: 'CENTER_BOX'});
        },

        _checkFct = function(opts) {
            return (hobs.context().window.location.pathname === url_dyn) === isTrue_dyn;
        },

        _checkTrueFct = function(opts, dfr) {
            this.done(hobs.Chaining.Step.STATE_PASSED);
        },

        _timeoutFct = function(opts, dfr) {
            this.done(hobs.Chaining.Step.STATE_FAILED);
        },

        _options = $.extend({}, options, {
            beforeCheckFct: _beforeCheckFct,
            checkTrueFct: _checkTrueFct,
            timeoutFct: _timeoutFct,
            demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY
        });

        hobs.teststeps.PollCheckTestStep.call(this, null, null, _checkFct, _options);
    };

    hobs.utils.definePrototype(
        hobs.actions.assert.location,
        hobs.teststeps.PollCheckTestStep,
        {
            'type' : hobs.actions.assert.namespace + ".location",
            'res-msg-passed' : 'Asserted ${test page location:2} is ${1} ${url:0}',
            'res-msg-failed' : 'Not asserted ${test page location:2} is ${1} ${url:0}'
        }
    );

}(window.hobs, $));


;

(function(hobs, $) {
    "use strict";

    /**
     * @class
     *
     * Checks if DOM Elements have (or not) specific text content
     *
     * @param {String} selector jQuery selector for the DOM Elements to check
     * @param {String} value the value of the text content
     * @param {boolean} [isTrue=true] Checks if text content is as expected or not
     * @param {TestActionOptions} [options] Test method options
     */
    hobs.actions.assert.text = function(selector, value, isTrue, options) {
        this.selector = selector;
        this.value = value;
        this.isTrue = (isTrue !== undefined && isTrue !== null) ? isTrue : true;

        var _assertion = this,
            selector_dyn = null,
            value_dyn = null,
            isTrue_dyn = null,

        _beforeCheckFct = function(opts) {
            // Process dynamic parameters
            selector_dyn = hobs.handleDynParameters(_assertion.selector, opts);
            value_dyn = hobs.handleDynParameters(_assertion.value, opts);
            isTrue_dyn = hobs.handleDynParameters(_assertion.isTrue, opts);

            _assertion.execData('args', [selector_dyn, (isTrue_dyn ? "" : "not"), value_dyn, null, options]);
        },

        _checkFct = function(opts) {
            var $el = hobs.utils.dom.getJQElFromSelector(_assertion.execData('args')[0], opts);
            _assertion.execData('element', $el);

            return (
                $el.length > 0
                && (($el.get(0).textContent === value_dyn) === isTrue_dyn)
            );
        },

        _checkTrueFct = function(opts, dfr) {
            _assertion.execData('args', [selector_dyn, (isTrue_dyn ? "" : "not"), value_dyn, _assertion.execData('element').get(0).textContent, options]);
            this.done(hobs.Chaining.Step.STATE_PASSED);
        },

        _timeoutFct = function(opts, dfr) {
            _assertion.execData('args', [selector_dyn, (isTrue_dyn ? "" : "not"), value_dyn]);

            if (_assertion.execData('element').length === 0) {
                _assertion.execData('msg', '${element:0} not found in the DOM!');
            }
            else {
                _assertion.execData('args', [selector_dyn, (isTrue_dyn ? "" : "not"), value_dyn, _assertion.execData('element').get(0).textContent, options]);
            }

            this.done(hobs.Chaining.Step.STATE_FAILED);
        },

        _options = $.extend({}, options, {
            beforeCheckFct: _beforeCheckFct,
            checkTrueFct: _checkTrueFct,
            timeoutFct: _timeoutFct,
            demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY
        });

        hobs.teststeps.PollCheckTestStep.call(this, null, null, _checkFct, _options);
    };

    hobs.utils.definePrototype(
        hobs.actions.assert.text,
        hobs.teststeps.PollCheckTestStep,
        {
            'type' : hobs.actions.assert.namespace + ".textContent",
            'res-msg-passed' : 'Asserted ${element:0} text is ${1} ${value:2}',
            'res-msg-failed' : 'Not asserted ${element:0} text is ${1} ${value:2} (${actual value:3})'
        }
    );

    // Alias
    hobs.actions.assert.textContent = hobs.actions.assert.text;

}(window.hobs, $));


;

(function(hobs, $) {
    "use strict";

    /**
     * @class
     *
     * Checks if a function returns true, every delay, until timeout
     *
     * @param {boolean|function} isTrue The expression that will be evaluate to true. A boolean or a function which returns a boolean
     * @param {TestActionOptions} [options] Test method options
     */
    hobs.actions.assert.isTrue = function(isTrue, options) {
        var _assertion = this;

        _assertion.isTrue = isTrue;

        function isTrueFn(opts) {
            // Process dynamic parameters
            var isTrue_dyn = hobs.handleDynParameters(_assertion.isTrue, opts);

            return isTrue_dyn === true;
        }

        var _checkFct = $.isFunction(_assertion.isTrue) ? _assertion.isTrue : isTrueFn,

            _beforeCheckFct = function(opts) {
                // Handle Demo Mode
                hobs.actions.handleDemoMode.call(_assertion, opts, null, 'blue', 'Asserting if something is true', {type: 'CENTER_BOX'});
            },

            _checkTrueFct = function(opts) {
                _assertion.execData('args', [_assertion.isTrue, options]);
                this.done(hobs.Chaining.Step.STATE_PASSED);
            },

            _timeoutFct = function(opts, dfr) {
                _assertion.execData('args', [_assertion.isTrue, options]);
                this.done(hobs.Chaining.Step.STATE_FAILED);
            },

            _options = $.extend({}, options, {timeoutFct: _timeoutFct, checkTrueFct: _checkTrueFct, beforeCheckFct: _beforeCheckFct, demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY});

        hobs.teststeps.PollCheckTestStep.call(this, null, null, _checkFct, _options);
    };

    hobs.utils.definePrototype(
        hobs.actions.assert.isTrue,
        hobs.teststeps.PollCheckTestStep,
        {
            'type' : hobs.actions.assert.namespace + ".isTrue",
            'res-msg-passed' : 'Asserted ${element:0} is true',
            'res-msg-failed' : 'Not asserted ${element:0} is true'
        }
    );

}(window.hobs, $));


;

(function(hobs, $) {
    "use strict";

    /**
     * @class
     *
     * Checks if a DOM element is considered "visible" by checking jQuery ":visible" attribute, every delay, until timeout
     *
     * @param {String} selector jQuery selector for the DOM Element to check
     * @param {boolean} [visible=true] Check visible or hidden status of the element
     * @param {TestActionOptions} [options] Test method options
     */
    hobs.actions.assert.visible = function(selector, visible, options) {
        this.selector = selector;
        this.visible = (visible !== undefined && visible !== null) ? visible : true;

        var _assertion = this,
            selector_dyn = null,
            visible_dyn = null,

        _beforeCheckFct = function(opts) {
            // Process dynamic parameters
            selector_dyn = hobs.handleDynParameters(_assertion.selector, opts);
            visible_dyn = hobs.handleDynParameters(_assertion.visible, opts);

            _assertion.execData('args', [selector_dyn, (visible_dyn ? "" : "not"), options]);

            // Handle Demo Mode
           hobs.actions.handleDemoMode.call(_assertion, opts, selector_dyn, 'blue', 'Asserting if ' + (visible_dyn ? '' : 'NOT ') + 'visible', {type: 'CENTER_BOX'});
        },

        _checkFct = function(opts) {
            var $el = hobs.utils.dom.getJQElFromSelector(_assertion.execData('args')[0], opts);
            _assertion.execData('element', $el);

            return (hobs.utils.dom.elementIsVisible($el) === visible_dyn);
        },

        _checkTrueFct = function(opts, dfr) {
            this.done(hobs.Chaining.Step.STATE_PASSED);
        },

        _timeoutFct = function(opts, dfr) {
            if (_assertion.execData('element').length === 0) {
                _assertion.execData('msg', '${element:0} not found in the DOM!');
            }
            this.done(hobs.Chaining.Step.STATE_FAILED);
        },

        _options = $.extend({}, options, {
            beforeCheckFct: _beforeCheckFct,
            checkTrueFct: _checkTrueFct,
            timeoutFct: _timeoutFct,
            demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY
        });

        hobs.teststeps.PollCheckTestStep.call(this, null, null, _checkFct, _options);
    };

    hobs.utils.definePrototype(
        hobs.actions.assert.visible,
        hobs.teststeps.PollCheckTestStep,
        {
            'type' : hobs.actions.assert.namespace + ".visible",
            'res-msg-passed' : 'Asserted ${element:0} is ${1} visible',
            'res-msg-failed' : 'Not asserted ${element:0} is ${1} visible'
        }
    );

    // Alias visible <=> visible
    hobs.actions.assert.isVisible = hobs.actions.assert.visible;

}(window.hobs, $));


;

(function(hobs, $) {
    "use strict";



    /**
     * @namespace
     *
     * @desc Test actions for Hobbes.js configuration
     *
     * **These classes are added to {@link hobs.TestCase} to make them available as follow:**
     *
     * @example
     *
     * new hobs.TestCase()
     *            .config.changeContext('iframe#subPage')
     *            (...)
     *            .config.resetContext()
     *
     */
    hobs.actions.config = hobs.actions.config || {};

    hobs.actions.config.namespace = "hobs.actions.config";



})(window.hobs, $);


;

(function(hobs, config, $) {
    "use strict";

    var _ctxBkp = null;



    /**
     * @class
     *
     * @name changeContext
     * @desc Change test execution context (to another window or iframe)
     *
     * @memberof hobs.actions.config
     *
     * @example
     *
     * new hobs.TestCase("tc#1")
     *
     *    // Navigate to shop home page
     *    .navigateTo("/shop/home.html")
     *
     *    .config.changeContext(function() {
     *      return hobs.find('#inner-iframe')
     *  })
     *  // From this point, test will execute in #inner-iframe context
     *  .click('button')
     *
     * @augments hobs.teststeps.PollCheckTestStep
     *
     * @param {function} ctxDomElementFn Function that returns the window object that becomes the new execution context
     * @param {TestActionOptions} [options] Test method extra options
     */
    hobs.actions.config.changeContext = function(ctxDomElementFn, options) {
        var _action = this;

        _action.ctxDomElementFn = ctxDomElementFn;
        _action.ctxDomElementFn_dyn = null;
        _action.newCtxDomEl = null;

        var _checkTrueFct = function(opts, dfr) {
            var callingstep = this;

            _action.newCtxDomEl = _action.ctxDomElementFn_dyn();

            _action.execData('args', [_action.ctxDomElementFn, options]);

            if($(_action.newCtxDomEl).length !== 1) {
                callingstep.done(
                    hobs.Chaining.Step.STATE_FAILED,
                    {
                        msg: "New context ${function:0} " + (($(_action.newCtxDomEl).length < 1) ? "not found in the DOM" : "found multiple elements to the DOM")
                    }
                );

                return;
            }

            try {
                _ctxBkp = hobs.context().loadEl;

                hobs.setContext(_action.newCtxDomEl);

                callingstep.done(hobs.Chaining.Step.STATE_PASSED);
            }
            catch(err) {
                _action.execData('args', [_action.ctxDomElementFn, err.stack, options]);

                callingstep.done(
                    hobs.Chaining.Step.STATE_FAILED,
                    {
                        msg: "Could not set test context to ${element:0} (${error:1})"
                    }
                );
            }
        },

        _beforeCheckFct = function(opts, dfr) {
            // Handle Demo Mode
            hobs.actions.handleDemoMode.call(_action, opts, null, 'blue', 'Changing test context', {type: 'CENTER_BOX'});

            // Process dynamic parameters
            _action.ctxDomElementFn_dyn = hobs.handleDynParameters(_action.ctxDomElementFn, opts);

            _action.step()._checkFct = _action.ctxDomElementFn_dyn;

            if (!$.isFunction(_action.ctxDomElementFn_dyn)) {
                _action.execData('args', ['type is ' + typeof(_action.ctxDomElementFn_dyn), options]);

                dfr.notify({
                    type : hobs.Chaining.Step.STATE_COMPLETED,
                    state : hobs.Chaining.Step.STATE_FAILED,
                    result : {
                        msg: "changeContext expects first ${argument:0} to be a function"
                    }
                });
            }
        },

        _options = $.extend({}, options, {beforeCheckFct: _beforeCheckFct, checkTrueFct: _checkTrueFct});

        hobs.teststeps.PollCheckTestStep.call(_action, null, null, null, _options);
    };

    hobs.utils.definePrototype(
        config.changeContext,
        hobs.teststeps.PollCheckTestStep,
        {
            'type' : config.namespace + ".changeContext",
            'res-msg-passed' : 'Context Changed to ${element:0}'
        }
    );



    /**
     * @class
     *
     * @name resetContext
     * @desc Change test execution context (to another window or iframe)
     *
     * @memberof hobs.actions.config
     *
     * @example
     *
     *  // Init test context to an iframe of the main window (#test-iframe)
     *  hobs.setContext($('#test-iframe').get(0));
     *
     *  new hobs.TestCase("tc#1")
     *
     *    // Navigate to shop home page
     *    .navigateTo("/shop/home.html")
     *
     *  // will change the context AND store the current context for possible reset
     *    .config.changeContext(function() {
     *      return hobs.find('#inner-iframe')
     *  })
     *  // => Now, context is #inner-iframe (inside #test-iframe)
     *
     *  // From this point, test will execute in #inner-iframe context
     *  .click('.inner-button')
     *
     *  // Reset to store context
     *  .config.resetContext()
     *  // => Now, context is #test-iframe
     *
     *  // will fail as .inner-button does not exist in context
     *  .click('.inner-button');
     *
     * @augments hobs.teststeps.PollCheckTestStep
     *
     * @param {TestStepOptions} [options] Test method extra options
     */
    hobs.actions.config.resetContext = function(options) {
        var _action = this;

        var stepFct = function(opts) {
            if (_ctxBkp && _ctxBkp !== hobs.context().loadEl) {
                hobs.setContext(_ctxBkp);
                _action.execData('args', [hobs.utils.dom.getXPath($(_ctxBkp).get(0)), options]);
                _ctxBkp = null;
                this.done(hobs.Chaining.Step.STATE_PASSED);
            }
            else {
                _action.execData('args', [options]);
                this.done(hobs.Chaining.Step.STATE_PASSED,
                    {
                        msg: "Test context has not been changed so nothing to reset"
                    }
                );
            }
        },

        step = new hobs.Chaining.Step(stepFct),

        _options = $.extend({}, options, {demoModeDelay: 0});

        hobs.TestStep.call(this, null, null, step, _options);
    };

    hobs.utils.definePrototype(
        config.resetContext,
        hobs.TestStep,
        {
            'type' : config.namespace + ".resetContext",
            'res-msg-passed' : 'Test context reset to default ${element:0}'
        }
    );



})(window.hobs, window.hobs.actions.config, $);


;

(function(hobs, $) {
    "use strict";

    /**
     * @namespace
     *
     * @desc Generic DOM elements test actions
     *
     * **These classes are added to {@link hobs.TestCase} to make them available as follow:**
     *
     * <pre>new hobs.TestCase()
     *                <span style="color:blue;">.click(...)
     *                 .mouseover(...)</span>
     *                (...)
     *                <span style="color:blue;">.sendKeys(...)</span></pre>
     *
     */
    hobs.actions.core = hobs.actions.core|| {};

    hobs.actions.core.namespace = "hobs.actions.core";

})(window.hobs, $);


;

(function(hobs, core, $) {
    "use strict";



    /**
     *
     * @typedef {TestStepOptions} ClickActionTestStepOptions
     * @type {TestStepOptions}
     * @property {boolean} [expectNav=false] Expect the click action to trigger a
     * page navigation. If true, Hobbes.js will wait until a page navigation
     * occurs. If no navigation occurs after 30s. (fixed timeout) the action
     * will be marked FAILED.
     *
     **/

    /**
     * @class
     *
     * @desc Looks for a DOM element and if found, triggers a click event on it
     *
     * @augments hobs.teststeps.jQSelectorPollCheckTestStep
     *
     * @param {String} selector jQuery selector for the DOM Element to click
     * @param {ClickActionTestStepOptions} [options] Test method options
     */
    hobs.actions.core.click = function(selector, options) {
        var _clickAction = this,
            checkTrueFct = null;

        _clickAction.selector = selector;

        function clickAction() {
            if (options && options.clickCenter === true) {
                var center = hobs.utils.dom.getElementCenter(_clickAction.execData('element'));
                hobs.utils.elementsFromPoint(center.x, center.y)[0].click();
            }
            else {
                _clickAction.execData('element').simulate('click');
            }
        }

        if (options && options.expectNav === true) {
            checkTrueFct = function(opts) {
                // Process dynamic parameters
                var // selector_dyn = hobs.handleDynParameters(_clickAction.selector, opts),
                    callingStep = this,
                    startLoadEventEnd,
                    interval = null,
                    navTimeout = null;

                // _clickAction.execData('args', [selector_dyn, options]);

                // Handle Demo Mode
                hobs.actions.handleDemoMode.call(_clickAction, opts, _clickAction.execData('args')[0], 'blue', 'Click with navigation');

                function getLoadEventEnd(obj) {
                    if ($.isWindow(obj)) {
                        return obj.performance.timing.loadEventEnd;
                    } else {
                        try {
                            return obj.contentWindow.performance.timing.loadEventEnd;
                        } catch(e) {
                            // most likely not implemented
                            return -1;
                        }
                    }
                }

                function navHandler() {
                    // Clear timeout
                    clearTimeout(navTimeout);

                    callingStep.done(hobs.Chaining.Step.STATE_PASSED);
                    $(hobs).trigger(hobs.CONTEXT_NAVIGATION_LOAD);
                }

                function navTimeoutHandler() {
                    // clear the interval if it exist
                    if (interval !== null) {
                        clearInterval(interval);
                    }

                    // Clear pending handlers
                    $(hobs.context().loadEl).off('load', navHandler);
                    $(hobs.context().window).off('beforeunload', navUnloadHandler);

                    _clickAction.resultMsg = "Click action did not trigger navigation";
                    callingStep.done(
                        hobs.Chaining.Step.STATE_FAILED,
                        {
                            msg: '${element:0} got clicked but no navigation occured!'
                        }
                    );
                }

                function isCheckLoadEndChanged() {
                    if (startLoadEventEnd === -1) {
                        return true;
                    }
                    var currentLoadEventEnd = getLoadEventEnd($(hobs.context().loadEl)[0]);
                    return currentLoadEventEnd > 0 && currentLoadEventEnd !== startLoadEventEnd;
                }

                function navUnloadHandler() {
                    // Clear timeout
                    clearTimeout(navTimeout);

                    hobs.context().document.documentElement.innerHTML = '';
                    startLoadEventEnd = getLoadEventEnd($(hobs.context().loadEl)[0]);

                    // check every 100 ms
                    interval = setInterval(function() {
                        if (isCheckLoadEndChanged()) {
                            // make sure to clear this interval
                            clearInterval(interval);
                            // then call the navigation handler
                            navHandler();
                        }
                    }, 100);

                    // Handles click action that did unload but loading time is too long
                    // Wait load event for hobs.config.navigation_timeout and then fails the action
                    navTimeout = setTimeout(navTimeoutHandler, hobs.config.navigation_timeout);
                }

                $(hobs.context().window).on('beforeunload', navUnloadHandler);

                clickAction.call(this);

                // Handles click action that do not result in navigation
                // Wait load event for hobs.config.navigation_timeout and then fails the action
                navTimeout = setTimeout(navTimeoutHandler, 2 * hobs.config.action_timeout);
            };
        } else {
            checkTrueFct = function(opts) {
                // // Process dynamic parameters
                // var selector_dyn = hobs.handleDynParameters(_clickAction.selector, opts);
                //
                // _clickAction.execData('args', [selector_dyn, options]);

                // Handle Demo Mode
                hobs.actions.handleDemoMode.call(_clickAction, opts, _clickAction.execData('args')[0], 'blue', 'Click');

                clickAction.call(this);

                this.done(hobs.Chaining.Step.STATE_PASSED);
            };
        }

        var _options = $.extend({}, options, {
            checkTrueFct: checkTrueFct,
            timeoutFct: hobs.actions.jQSelectorPollCheckTestStepTimeoutFct.bind(this),
            demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY
        });

        hobs.teststeps.jQSelectorPollCheckTestStep.call(this, null, null, selector, _options);
    };

    hobs.utils.definePrototype(
        core.click,
        hobs.teststeps.jQSelectorPollCheckTestStep,
        {
            'type' : core.namespace + ".click",
            'res-msg-passed' : 'Clicked ${element:0}',
            'res-msg-failed' : 'Click on ${element:0} failed'
        }
    );

})(window.hobs, window.hobs.actions.core, $);


;

(function(hobs, core, $) {
    "use strict";



    /**
     * @class
     *
     * Dispatch a custom event on a DOM element
     *
     * @augments hobs.teststeps.jQSelectorPollCheckTestStep
     *
     * @memberof hobs.actions.core
     *
     * @see window.CustomEvent
     *
     * @param {String} selector jQuery selector of the DOM element target of the event
     * @param {CustomEvent|String} event {@link window.CustomEvent} or String representing the name of the event to dispatch (mouseover, mouseout etc..)
     * @param {Object} params Parameters of the event to create (only if event is passed as a string)
     * @param {TestActionOptions} options Test method options
     */
    hobs.actions.core.dispatchEvent = function(selector, event, params, options) {
        var _action = this,
            checkTrueFct = function(opts) {
                // Process dynamic parameters
                // var selector_dyn = hobs.handleDynParameters(_action.selector, opts);
                var params_dyn = hobs.handleDynParameters(_action.params, opts);
                var evt = $.type(event) === "string" ? new window.CustomEvent(event, params_dyn) : event;

                _action.execData('args', [evt.type, params_dyn, _action.execData('args')[0], options]);

                // Handle Demo Mode
                hobs.actions.handleDemoMode.call(_action, opts, _action.execData('args')[0], 'blue', 'Dispatch Event');

                _action.execData('element').get(0).dispatchEvent(evt);
                this.done(hobs.Chaining.Step.STATE_PASSED);
            },

        _options = $.extend({}, options, {
            checkTrueFct: checkTrueFct,
            timeoutFct: hobs.actions.jQSelectorPollCheckTestStepTimeoutFct.bind(this),
            demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY
        });

        _action.selector = selector;
        _action.params = params;

        hobs.teststeps.jQSelectorPollCheckTestStep.call(this, null, null, selector, _options);
    };

    hobs.utils.definePrototype(
        core.dispatchEvent,
        hobs.teststeps.jQSelectorPollCheckTestStep,
        {
            'type' : core.namespace + ".dispatchEvent",
            'res-msg-passed' : 'Dispatched ${event:0} (with ${params:1}) on ${element:2}',
            'res-msg-failed' : 'Dispatch of ${event:0} (with ${params:1}) on ${element:2} failed'
        }
    );



})(window.hobs, window.hobs.actions.core, $);


;

(function(hobs, core, $) {
    "use strict";

    /**
     * @class
     *
     * **Executes sync/async javascript code**
     *
     * @example <caption>Execute synchronous code</caption>
     *
     * new hobs.TestCase("tc")
     *      // will always be marked as PASSED
     *      .execFct(function() {
     *          // Synchronous Javascript code
     *          var i = 0;
     *      })
     *
     * @example <caption>Execute asynchronous code</caption>
     *
     * new hobs.TestCase("tc")
     *      // will always be marked as PASSED
     *      .execFct(function(opts, done) {
     *          // Asynchronous Javascript code
     *          setTimeout(function() {
     *              var i = 0;
     *
     *              // Call done function to finish execFct action and continue testCase execution
     *              done();
     *          }, 5000);
     *      })
     *
     *      // will wait 5s. before being executed
     *      .click("button")
     *
     * @example <caption>Control .execFct result (pass/fail)</caption>
     *
     * //By default, .execFct is always marked as passed. Though .execFct will be marked failed in following cases:
     *
     * // The passed function returned false:
     * new hobs.TestCase("tc")
     *      .execFct(function() {
     *              return false;
     *      })
     *
     * // The passed function throws an exception
     * new hobs.TestCase("tc")
     *      .execFct(function() {
     *              var i = {};
     *              // i.a.prop do not exist, function will throw an exception
     *              i.a.prop = "blah";
     *      })
     *
     * // The passed asynchronous function fails to call done() within the timeout specified in the options:
     * new hobs.TestCase("tc")
     *      .execFct(function(opts, done) {
     *          // Asynchronous Javascript code
     *          setTimeout(function() {
     *              done();
     *          }, 5000);
     *      }, { timeout: 1000 })
     *
     * // The passed asynchronous function fails by calling done(false,message) as arguments:
     * new hobs.TestCase("tc")
     *      .execFct(function(opts, done) {
     *          // Asynchronous Javascript code
     *          setTimeout(function() {
     *              done(false, "some error message");
     *          }, 500);
     *      }, { timeout: 1000 })
     *
     * @memberof hobs.actions.core
     *
     * @augments hobs.TestStep
     *
     * @param {Object} fct The function that will be executed
     * @param {TestStepOptions} [options] Test method options (Accepts: "delay", "timeout")
     */
    hobs.actions.core.execFct = function(fct, options) {
        var _action = this;
        _action.fct = fct;


        var syncFct = function(opts) {
            var callingStep = this;
            // Process dynamic parameters
            var fct_dyn = hobs.handleDynParameters(_action.fct, opts);
            var timeout = null;

            function doneHandler(success, message) {
                if (success !== undefined && success === false) {
                    var errorMessage = message || "function returned failed without message";
                    _action.execData('args', [fct_dyn, errorMessage, options]);
                    callingStep.done(hobs.Chaining.Step.STATE_FAILED);
                } else {
                _action.execData('args', [fct_dyn, options]);
                    callingStep.done(hobs.Chaining.Step.STATE_PASSED);
                }
            }

            function timeoutHandler() {
                _action.execData('args', [fct_dyn, "function timed out!", options]);
                callingStep.done(hobs.Chaining.Step.STATE_FAILED);
            }

            // Handle Demo Mode
            hobs.actions.handleDemoMode.call(_action, opts, null, 'blue', 'Executing Javascript code', {type: 'CENTER_BOX'});

            var done = function (success, message) {
                clearTimeout(timeout);
                //if (step.dfr()) {
                    timeout = setTimeout(function() { doneHandler(success, message); }, 50);
                //}
            };

            try {
                if (fct_dyn.length > 1) {
                    // Install a timeout that will resolve the step if it fails to call done() in time
                    var _opts = $.extend({timeout: hobs.config.global_timeout}, opts);
                    timeout = setTimeout(timeoutHandler, _opts.timeout);
                    fct_dyn(opts, done);
                } else {
                    var ret = fct_dyn(opts);

                    if (ret !== undefined && ret !== true) {
                        _action.execData('args', [fct_dyn, "function returned false!", options]);
                        callingStep.done(hobs.Chaining.Step.STATE_FAILED);
                    }

                    else {
                        done();
                    }
                }
            }
            catch(err) {
                clearTimeout(timeout);
                _action.execData('args', [fct_dyn, err.stack, options]);
                callingStep.done(hobs.Chaining.Step.STATE_FAILED);
            }
        },

        _options = $.extend({}, options, {demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY}),

        step = new hobs.Chaining.Step(syncFct, options);

        hobs.TestStep.call(this, null, null, step, _options);
    };

    hobs.utils.definePrototype(
        core.execFct,
        hobs.TestStep,
        {
            'type' : core.namespace + ".execFct",
            'res-msg-passed' : 'Executed ${function:0}',
            'res-msg-failed' : 'Execution of ${function:0} failed with ${error message:1}'
        }
    );

    /**
     * @class
     *
     * Alias **Executes sync/async javascript code**
     *
     * @see hobs.actions.core.execFct
     *
     * @memberof hobs.actions.core
     */
    hobs.actions.core.execSyncFct = hobs.actions.core.execFct;



})(window.hobs, window.hobs.actions.core, $);


;

(function(hobs, core, $) {
    "use strict";



    /**
     * @class
     *
     * @desc Executes a Hobbes.js TestCase
     *
     * @memberof hobs.actions.core
     *
     * @augments hobs.TestStep
     *
     * @param {Object} testCase The existing test case to execute
     * @param {boolean} [resetLocation=false] Store the URL before executing the test case and go back to it after execution
     * @param {TestStepOptions} [options] Test method options
     */
    hobs.actions.core.execTestCase = function(testcase, resetLocation, options) {
        if (!testcase || hobs.TestSuite.prototype.isPrototypeOf(testcase) ) {
            this.testcase = null;
        }
        else {
            this.testcase = testcase.clone();
        }

        this.resetLocation = resetLocation !== null ? resetLocation : false;

        hobs.TestStep.call(this, null, null, this.testcase, options);
    };

    hobs.utils.definePrototype(
        core.execTestCase,
        hobs.TestStep,
        {
            'type' : core.namespace + ".execTestCase",
            'execTestStepFct' : function(opts) {
                var _action = this;

                _action._result = null;

                var options = this.generateTestChain(opts);
                options = hobs.handleDynParameters(options, opts);

                if (this.resetLocation) {
                    var storedUrl = hobs.context().window.location.href;
                    _action._testChain.addStep(new hobs.actions.core.navigateTo(storedUrl));
                }

                function progressHandler(notification) {
                    // if (notification.type === hobs.Chaining.Step.STATE_COMPLETED) {
                    // }
                    if (notification.state === hobs.Chaining.Step.STATE_PAUSED) {
                        _action._testChain.pause();
                    }
                    else if (notification.state === hobs.Chaining.Step.STATE_RESUMED) {
                        _action._testChain.resume();
                    }
                }

                function chainProgressHandler(notification) {
                    if (notification && _action._testChain && (notification.state === hobs.Chaining.Step.STATE_PASSED || notification.state === hobs.Chaining.Step.STATE_FAILED)) {

                        _action._timing.end = Date.now();

                        _action._state = notification.state;

                        _action.execData('args', [_action.testcase.name, _action.testcase, _action.resetLocation]);

                        _action.executionEndHandler({
                            result: (_action._testChain.state() === hobs.Chaining.Step.STATE_PASSED ? hobs.Chaining.Step.STATE_PASSED : hobs.Chaining.Step.STATE_FAILED),
                            args: [_action.testcase.name, _action.testcase, _action.resetLocation]
                        });

                        if(options.demoMode && options.demoMode === true) {
                            _action.demoModeOut();
                        }

                        if (_action.dfr()) {
                            _action.done(_action._state);
                        }
                    }
        //            _action._testChain = null;
                }

                this.dfr().progress(progressHandler);

                // Handle Demo Mode
                hobs.actions.handleDemoMode.call(_action, opts, null, 'blue', 'Executing a TestCase', {type: 'CENTER_BOX'});

                _action._timing.start = Date.now();

                this._testChain
                    .exec(options)
                    .progress(chainProgressHandler);
                    // .always(alwaysHandler);
            },
            'result' : function(format, withDetails) {
                if (this._result) {
                    return this._result;
                }

                var res = hobs.TestStep.prototype.result.call(this, format, withDetails);

                //var tcRes = this.testcase.result().steps;
                //res.steps = [this.testcase.result(format, withDetails)];

                return res;
            },
            'res-msg-passed' : 'Execution of ${test case:0} passed',
            'res-msg-failed' : 'Execution of ${test case:0} failed'
        }
    );



})(window.hobs, window.hobs.actions.core, $);


;

(function(hobs, core, $) {
    "use strict";



    /**
     * @class
     *
     * sets text value of an input type DOM element
     *
     * @memberof hobs.actions.core
     *
     * @augments hobs.teststeps.jQSelectorPollCheckTestStep
     *
     * @param {String} selector jQuery selector of the target DOM Element
     * @param {String} [text=""] The text to fill the input with
     * @param {TestActionOptions} [options] Test method options
     */
    hobs.actions.core.fillInput = function(selector, text, options) {
        var _action = this;

        _action.selector = selector;
        _action.text = text;

        var checkTrueFct = function(opts) {
            // Process dynamic parameters
            var // selector_dyn = hobs.handleDynParameters(_action.selector, opts),
                text_dyn = hobs.handleDynParameters(_action.text, opts);

            _action.execData('args', [_action.execData('args')[0], text_dyn, options]);

            // Handle Demo Mode
            hobs.actions.handleDemoMode.call(_action, opts, _action.execData('args')[0], 'blue', 'Fill input with text "' + text_dyn + '"');

            var retries = 0;
            do {
                try {
                    _action.execData('element').val(text_dyn);
                    var evt = hobs.context().document.createEvent('CustomEvent');
                    evt.initCustomEvent('input', true, true, {bubbles: true});
                    _action.execData('element').get(0).dispatchEvent(evt);
                    this.done(hobs.Chaining.Step.STATE_PASSED);
                    return;
                } catch (e) {
                    // ignore errors
                }
            } while (retries++ < hobs.config.ie11_maxretries);

            this.done(hobs.Chaining.Step.STATE_FAILED);
        },

        _options = $.extend({}, options, {
            checkTrueFct: checkTrueFct,
            timeoutFct: hobs.actions.jQSelectorPollCheckTestStepTimeoutFct.bind(this),
            demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY
        });

        hobs.teststeps.jQSelectorPollCheckTestStep.call(this, null, null, selector, _options);
    };

    hobs.utils.definePrototype(
        core.fillInput,
        hobs.teststeps.jQSelectorPollCheckTestStep,
        {
            'type' : core.namespace + ".fillInput",
            'res-msg-passed' : 'Filled ${element:0} with ${text:1}',
            'res-msg-failed' : 'Fill ${element:0} with ${text:1} failed'
        }
    );



})(window.hobs, window.hobs.actions.core, $);


;

(function(hobs, core, $) {
    "use strict";



    /**
     * @class
     *
     * @name ifElse
     * @desc Conditional execution
     *
     * @memberof hobs.actions.core
     *
     * @example
     *
     * new hobs.TestCase("tc#1")
     *
     *    // Navigate to shop home page
     *    .navigateTo("/shop/home.html")
     *
     *    // If First load modal is present, remove it
     *    .ifElse(
     *      // condition function, return true if modal is present on shop home page
     *        function() { return hobs.find(".first-load-pop-up-modal").length > 0; },
     *      // if the modal is present, execute following test case to remove it
     *         new hobs.TestCase("Close first load modal")
     *                .click(".first-load-pop-up-modal .close-button")
     *    )
     *
     *    // Continue test...
     *
     * @augments hobs.teststeps.PollCheckTestStep
     *
     * @param {boolean|function} condition to evalute to true/false
     * @param {hobs.TestSuite|hobs.TestCase} execIfTrue test element executed if `condition` has been evaluated to `true`
     * @param {hobs.TestSuite|hobs.TestCase} execIfFalse test element executed if `condition` has been evaluated to `false`
     * @param {TestActionOptions} [options] Test method extra options
     */
    hobs.actions.core.ifElse = function(condition, execIfTrue, execIfFalse, options) {
        var _action = this;
            // checkTruefct = null;

        _action.condition = condition;
        _action.execIfTrue = execIfTrue ? execIfTrue.clone() : null;
        _action.execIfFalse = execIfFalse ? execIfFalse.clone() : null;
        _action.execIfTrueFn = null;
        _action.execIfFalseFn = null;
        _action.conditionExecuted = null;
        _action.conditionResult = null;

        function conditionFn(opts) {
            // Process dynamic parameters
            var condition_dyn = hobs.handleDynParameters(_action.condition, opts),
                res = (condition_dyn === true || false);

            _action.conditionResult = res;

            return res;
        }

        var checkFct = $.isFunction(condition) ? condition : conditionFn;

        _action.execIfTrueName = 'void';
        _action.execIfFalseName = 'void';

        // Default execIfFalse to handle timeout without execIfFalse condition to execute
        _action.execIfFalseFn = function(opts, dfr) {
            _action.conditionResult = false;
            _action.conditionExecuted = 'void';
            this.done(hobs.Chaining.Step.STATE_PASSED);
        };

        // Default execIfFalse to handle timeout without execIfFalse condition to execute
        _action.execIfTrueFn = function(opts, dfr) {
            _action.conditionResult = true;
            _action.conditionExecuted = 'void';
            this.done(hobs.Chaining.Step.STATE_PASSED);
        };

        if (_action.execIfTrue !== undefined && _action.execIfTrue !== null) {
            _action.execIfTrueName = _action.execIfTrue.name;
            _action.execIfTrueFn = function(opts, dfr) {
                var callingstep = this;
                _action.conditionResult = true;
                _action.conditionExecuted = _action.execIfTrue;
                _action.execIfTrue.exec(opts).then(function(res) {
                    _action.executedStep = _action.execIfTrue;
                    callingstep.done(res.result);
                });
            };
        }

        if (_action.execIfFalse !== undefined && _action.execIfFalse !== null) {
            _action.execIfFalseName = _action.execIfFalse.name;
            _action.execIfFalseFn = function(opts, dfr) {
                var callingstep = this;
                _action.conditionResult = false;
                _action.conditionExecuted = _action.execIfFalse;
                _action.execIfFalse.exec(opts).then(function(res) {
                    _action.executedStep = _action.execIfFalse;
                    callingstep.done(res.result);
                });
            };
        }

        var _options = $.extend({}, options, {checkTrueFct: _action.execIfTrueFn, timeoutFct: _action.execIfFalseFn, demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY, timeoutState: hobs.Chaining.Step.STATE_PASSED});

        hobs.teststeps.PollCheckTestStep.call(this, ".ifElse", null, checkFct, _options);

        _action.execData('args', [_action.condition, _action.execIfTrueName, _action.execIfFalseName, options]);
    };

    hobs.utils.definePrototype(
        core.ifElse,
        hobs.teststeps.PollCheckTestStep,
        {
            'type' : core.namespace + ".ifElse",
            'result' : function(format, withDetails) {
                if (this._result) {
                    return this._result;
                }

                var res = hobs.TestStep.prototype.result.call(this, format, withDetails);

                if (this.executedStep !== undefined) {
                    res.steps = [this.executedStep.result(format, withDetails)];
                }

                return res;
            },
            'res-msg-passed' : 'Execution of condition if ${this:0} then ${exec true case:1} else ${exec false case:2} passed',
            'res-msg-failed' : 'Execution of condition if ${this:0} then ${exec true case:1} else ${exec false case:2} failed'
        }
    );

    /**
     * @deprecated
     *
     * @class
     *
     * @alias hobs.actions.core.if
     *
     * @see Replaced by {@link hobs.actions.core.ifElse}
     */
    hobs.actions.core["if"] = hobs.actions.core.ifElse;


})(window.hobs, window.hobs.actions.core, $);


;

(function(hobs, core, $) {
    "use strict";



    /**
     * @class
     *
     * Simulates mouseout interaction on a DOM element
     *
     * @memberof hobs.actions.core
     *
     * @augments hobs.teststeps.jQSelectorPollCheckTestStep
     *
     * @param {String} selector jQuery selector for the DOM Element to mouse out
     * @param {TestActionOptions} [options] Test method options
     */
    hobs.actions.core.mouseout = function(selector, options) {
        var _action = this,
            checkTrueFct = function(opts) {
                // // Process dynamic parameters
                // var selector_dyn = hobs.handleDynParameters(_action.selector, opts);
                //
                // _action.execData('args', [selector_dyn, options]);

                // Handle Demo Mode
                hobs.actions.handleDemoMode.call(_action, opts, _action.execData('args')[0], 'blue', 'mouseout');

                var evt = hobs.context().document.createEvent('MouseEvents');
                evt.initMouseEvent('mouseout', true, true, hobs.context().window, 1, 1, 1, 1, 1, false, false, false, false, 0, null);
                _action.execData('element').get(0).dispatchEvent(evt);

                this.done(hobs.Chaining.Step.STATE_PASSED);
            },

            _options = $.extend({}, options, {
                checkTrueFct: checkTrueFct,
                timeoutFct: hobs.actions.jQSelectorPollCheckTestStepTimeoutFct.bind(this),
                demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY
            });

        hobs.teststeps.jQSelectorPollCheckTestStep.call(this, null, null, selector, _options);
    };

    hobs.utils.definePrototype(
        core.mouseout,
        hobs.teststeps.jQSelectorPollCheckTestStep,
        {
            'type' : core.namespace + ".mouseout",
            'res-msg-passed' : 'Mouseout ${element:0}',
            'res-msg-failed' : 'Mouseout on ${element:0} failed'
        }
    );



})(window.hobs, window.hobs.actions.core, $);


;

(function(hobs, core, $) {
    "use strict";



    /**
     * @class
     *
     * Simulates mouseover interaction on a DOM element
     *
     * @memberof hobs.actions.core
     *
     * @augments hobs.teststeps.jQSelectorPollCheckTestStep
     *
     * @param {String} selector jQuery selector for the DOM Element to mouse over
     * @param {TestActionOptions} [options] Test method options
     */
    hobs.actions.core.mouseover = function(selector, options) {
        var _action = this,
            checkTrueFct = function(opts) {
                // // Process dynamic parameters
                // var selector_dyn = hobs.handleDynParameters(_action.selector, opts);
                //
                // _action.execData('args', [selector_dyn, opts]);

                // Handle Demo Mode
                hobs.actions.handleDemoMode.call(_action, opts, _action.execData('args')[0], 'blue', 'mouseover');

                var evt = hobs.context().document.createEvent('MouseEvents');
                evt.initMouseEvent('mouseover', true, true, hobs.context().window, 1, 1, 1, 1, 1, false, false, false, false, 0, null);
                _action.execData('element').get(0).dispatchEvent(evt);

                this.done(hobs.Chaining.Step.STATE_PASSED);
            },

            _options = $.extend({}, options, {
                checkTrueFct: checkTrueFct,
                timeoutFct: hobs.actions.jQSelectorPollCheckTestStepTimeoutFct.bind(this),
                demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY
            });

        _action.selector = selector;

        hobs.teststeps.jQSelectorPollCheckTestStep.call(this, null, null, selector, _options);
    };

    hobs.utils.definePrototype(
        core.mouseover,
        hobs.teststeps.jQSelectorPollCheckTestStep,
        {
            // 'constructor' : hobs.actions.core.mouseover,
            'type' : core.namespace + ".mouseover",
            'res-msg-passed' : 'Mouseover ${element:0}',
            'res-msg-failed' : 'Mouseover on ${element:0} failed'
        }
    );



})(window.hobs, window.hobs.actions.core, $);


;

(function(hobs, core, $) {
    "use strict";



    /**
     * @class
     *
     * Forces the Browser to navigate to another URL
     *
     * @memberof hobs.actions.core
     *
     * @augments hobs.TestStep
     *
     * @param {String} url Destination URL
     * @param {TestStepOptions} [options] Test method options
     */
    hobs.actions.core.navigateTo = function(url, options) {
        var _step = this;
        _step.url = url;

        var navigateFct = function(opts) {
            var callingStep = this;
            // Process dynamic parameters
            var url_dyn = hobs.handleDynParameters(_step.url, opts);

            _step.execData('args', [url_dyn, options]);

            // Handle Demo Mode
            hobs.actions.handleDemoMode.call(_step, opts, null, 'blue', 'Explicit Navigation', {type: 'CENTER_BOX'});

            hobs.navigate(url_dyn, options).then(function(passed, params) {
                    if (passed) {
                        callingStep.done(hobs.Chaining.Step.STATE_PASSED);
                    }
                    else {
                        _step.execData('args', [params.url, options, params.msg]);

                        callingStep.done(hobs.Chaining.Step.STATE_FAILED);
                    }
            });
        },

        _options = $.extend({}, options, {demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY}),

        step = new hobs.Chaining.Step(navigateFct, options);

        hobs.TestStep.call(this, null, null, step, _options);
    };

    hobs.utils.definePrototype(
        core.navigateTo,
        hobs.TestStep,
        {
            'type' : core.namespace + ".navigateTo",
            'res-msg-passed' : 'Navigated to ${url:0}',
            'res-msg-failed' : 'Navigation to ${url:0} failed with ${Message:2}'
        }
    );

    // Alias
    hobs.actions.core.navigate = hobs.actions.core.navigateTo;



})(window.hobs, window.hobs.actions.core, $);


;

(function(hobs, core, $) {
    "use strict";



    /**
    *
    * @typedef {TestStepOptions} OpenWindowTestStepOptions
    * @type {TestStepOptions}
    * @property {function} [success] Function executed once the new window has been loaded. First (and only) argument passed to the function is the reference to newly opened window
    *
    **/

    /**
     * @class
     *
     * **Opens a URL in a new window**
     *
     * @memberof hobs.actions.core
     *
     * @example <caption>Open a new window and close it directly</caption>
     *
     * new hobs.TestCase("tc")
     *      .openWindow("", null, {success: function(window) {
     *          // window argument is the reference to the newly opened window
     *          window.close();
     *      }})
     *
     * @example <caption>Open a new window and store its reference to test its content</caption>
     *
     * // Init varaible to store window reference
     * var popup = null;
     *
     * new hobs.TestCase("tc")
     *      .openWindow("", null, {success: function(window) {
     *          // window argument is the reference to the newly opened window
     *          popup = window;
     *      }})
     *      // Assert popup content
     *      .asserts.isTrue(function() {
     *          return hobs.find('.new-window-div', popup).length > 0;
     *      })
     *      // close popup
     *      .execFct(function() {
     *          popup.close();
     *      })
     *
     * @augments hobs.TestStep
     *
     * @param {string} url The function that will be executed in a try catch block
     * @param {string} [winOptions] Control whether the function is expected to throw an exception or not
     * @param {OpenWindowTestStepOptions} [options] Test method options (Accepts: "delay")
     */
    hobs.actions.core.openWindow = function(url, winOptions, options) {
        var _action = this;

        _action.url = url || null;
        _action.winOptions = winOptions || hobs.config.default_win_options;

        var stepFct = function(opts) {
            var callingStep = this;
            // Process dynamic parameters
            var url_dyn = hobs.handleDynParameters(_action.url, opts);
            var winOptions_dyn = hobs.handleDynParameters(_action.winOptions, opts);

            // Handle Demo Mode
            hobs.actions.handleDemoMode.call(_action, opts, null, 'blue', 'Opening ' + url_dyn + ' in a new window', {type: 'CENTER_BOX'});

            function navHandler(isUrlSafe, params) {
                // isUrlSafe == true means the URL is OK to navigate to.
                if (isUrlSafe) {
                    var loadCheckIntervalHandler = function() {
                        if (newWindow.performance && newWindow.performance.timing && newWindow.performance.timing.loadEventEnd) {
                            clearTimeout(navTimeout);
                            clearInterval(loadCheckInterval);

                            if(opts.success && $.isFunction(opts.success)) {
                                try {
                                    opts.success.call(this, newWindow);
                                }
                                catch (e) {
                                    hobs.log(e);
                                }
                            }

                            // setTimeout(function() {
                                _action.execData('args', [params.url, newWindow.performance.timing, options]);
                                callingStep.done(hobs.Chaining.Step.STATE_PASSED);
                            // }, 0);
                        }
                        else {
                            hobs.log("Not yet loaded ...");
                        }
                    };

                    var newWindow = window.open(params.url, null, winOptions_dyn),
                        loadCheckInterval = setInterval(loadCheckIntervalHandler, 500),
                        navTimeoutHandler = function() {
                            clearInterval(loadCheckInterval);
                            _action.execData('args', [params.url, hobs.config.navigation_timeout, options]);
                            callingStep.done(
                                hobs.Chaining.Step.STATE_FAILED,
                                {
                                    msg: 'Timeout (${1}ms.) while trying to load ${url:0} in a new window'
                                }
                            );
                        },
                        navTimeout = setTimeout(navTimeoutHandler, hobs.config.navigation_timeout);

                }
                // Issue with the target URL, do not execute navigation
                else {
                    _action.execData('args', [params.url, params.msg, options]);
                    callingStep.done(hobs.Chaining.Step.STATE_FAILED);
                }
            }

            // Check target URL
            hobs.navigate(url_dyn, true)
                // Then, once URL got checked (no navigation occured)
                .then(navHandler);
        },

        step = new hobs.Chaining.Step(stepFct),

        _options = $.extend({}, options, {demoModeDelay: 0});

        hobs.TestStep.call(this, null, null, step, _options);
    };

    hobs.utils.definePrototype(
        core.openWindow,
        hobs.TestStep,
        {
            'type' : core.namespace + ".openWindow",
            'res-msg-passed' : 'Opened ${url:0} in a new window',
            'res-msg-failed' : 'Cannot open ${url:0} in a new window (${Message:1})'
        }
    );



})(window.hobs, window.hobs.actions.core, $);


;

(function(hobs, core, $) {
    "use strict";



    /**
     * @class
     *
     * Reloads the current page
     *
     * @memberof hobs.actions.core
     *
     * @augments hobs.TestStep
     *
     * @param {TestStepOptions} [options] Test method options
     */
    hobs.actions.core.reload = function(options) {
        var _action = this;

        var reloadFct = function(opts) {
            var callingstep = this;

            var loadCheckInterval = null,
                navTimeout = null;

            // Handle Demo Mode
            hobs.actions.handleDemoMode.call(_action, opts, null, 'blue', 'Reload Current Page', {type: 'CENTER_BOX'});

            if ($.isWindow(hobs.context().loadEl)) {
                loadCheckInterval = setInterval(loadCheckIntervalHandler, 500),
                navTimeout = setTimeout(navTimeoutHandler, hobs.config.navigation_timeout);
            }
            else {
                $(hobs.context().loadEl).one('load', loadHandler);
            }

            hobs.context().window.location.reload(true);

            function loadHandler() {
                _action.execData('args', [hobs.context().window.location.pathname, options]);
                callingstep.done(hobs.Chaining.Step.STATE_PASSED);
                $(hobs).trigger(hobs.CONTEXT_NAVIGATION_LOAD);
            }

            function navTimeoutHandler() {
                clearInterval(loadCheckInterval);
                _action.execData('args', [hobs.context().window.location.pathname, options]);
                callingstep.done(hobs.Chaining.Step.STATE_FAILED);
                // $(hobs).trigger(hobs.CONTEXT_NAVIGATION_LOAD);
            }

            function loadCheckIntervalHandler() {
                var perf = hobs.context().window.performance;
                if (perf && perf.timing && perf.timing.loadEventEnd && perf.timing.loadEventEnd > 0) {
                    clearTimeout(navTimeout);
                    clearInterval(loadCheckInterval);
                    _action.execData('args', [hobs.context().window.location.pathname, options]);
                    callingstep.done(hobs.Chaining.Step.STATE_PASSED);
                    $(hobs).trigger(hobs.CONTEXT_NAVIGATION_LOAD);
                }
            }
        },

        _options = $.extend({}, options, {demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY}),

        step = new hobs.Chaining.Step(reloadFct, options);

        hobs.TestStep.call(this, null, null, step, _options);
    };

    hobs.utils.definePrototype(
        core.reload,
        hobs.TestStep,
        {
            'type' : core.namespace + ".reload",
            'res-msg-passed' : 'Reloaded ${current page:0}',
            'res-msg-failed' : 'Reload of ${current page:0} failed'
        }
    );

    // Alias
    hobs.actions.core.reloadPage = hobs.actions.core.reload;



})(window.hobs, window.hobs.actions.core, $);


;

(function(hobs, core, $) {
    "use strict";



    /**
     * @class
     *
     * Simulates key sequence on an input type DOM element
     *
     * @memberof hobs.actions.core
     *
     * @augments hobs.teststeps.jQSelectorPollCheckTestStep
     *
     * Uses "key-sequence" type of {@link https://github.com/jquery/jquery-simulate}
     *
     * @param {String} selector jQuery selector for the DOM Element to send the keys to
     * @param {String} [keySequence=""] The sequence of keys to send
     * @param {TestActionOptions} [options] Test method options
     */
    hobs.actions.core.sendKeys = function(selector, keySequence, options) {
        var _action = this;

        // _action.selector = selector;
        _action.keySequence = keySequence;

        var checkTrueFct = function(opts) {
            // Process dynamic parameters
            var // selector_dyn = hobs.handleDynParameters(_action.selector, opts),
                keySequence_dyn = hobs.handleDynParameters(_action.keySequence, opts);

            _action.execData('args', [_action.execData('args')[0], keySequence_dyn, options]);

            // Handle Demo Mode
            hobs.actions.handleDemoMode.call(_action, opts, _action.execData('args')[0], 'blue', 'Type "' + keySequence_dyn + '" in input');

            _action.execData('element').simulate('key-sequence', {sequence: keySequence_dyn});

            this.done(hobs.Chaining.Step.STATE_PASSED);
        },

        _options = $.extend({}, options, {
            checkTrueFct: checkTrueFct,
            timeoutFct: hobs.actions.jQSelectorPollCheckTestStepTimeoutFct.bind(this),
            demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY
        });

        hobs.teststeps.jQSelectorPollCheckTestStep.call(this, null, null, selector, _options);
    };

    hobs.utils.definePrototype(
        core.sendKeys,
        hobs.teststeps.jQSelectorPollCheckTestStep,
        {
            'type' : core.namespace + ".sendKeys",
            'res-msg-passed' : 'Sent ${key sequence:1} to ${element:0}',
            'res-msg-failed' : 'Sending of ${key sequence:1} to ${element:0} failed'
        }
    );

})(window.hobs, window.hobs.actions.core, $);


;

(function(hobs, core, $) {
    "use strict";



    /**
     * @class
     *
     * jQuery.simulate wrapper {@link https://github.com/jquery/jquery-simulate}
     *
     * @memberof hobs.actions.core
     *
     * @augments hobs.teststeps.jQSelectorPollCheckTestStep
     *
     * @param {String} selector jQuery target selector
     * @param {String} simType Simulation action
     * @param {Object} [simOptions={}] Options used for the simulation
     * @param {TestActionOptions} [options] Test method options
     */
    hobs.actions.core.simulate = function(selector, simType, simOptions, options) {
        var _action = this;

        _action.selector = selector;
        _action.simType = simType;
        _action.simOptions = simOptions || {};

        var checkTrueFct = function(opts) {
            // Process dynamic parameters
            var // selector_dyn = hobs.handleDynParameters(_action.selector, opts),
                simType_dyn = hobs.handleDynParameters(_action.simType, opts),
                simOptions_dyn = hobs.handleDynParameters(_action.simOptions, opts);

            _action.execData('args', [_action.execData('args')[0], simType_dyn, simOptions_dyn, options]);

            // Handle Demo Mode
            hobs.actions.handleDemoMode.call(_action, opts, _action.execData('args')[0], 'blue', 'Simulating ' + simType_dyn + ' event');

            _action.execData('element').simulate(simType_dyn, simOptions_dyn);
               this.done(hobs.Chaining.Step.STATE_PASSED);
        },

        _options = $.extend({}, options, {
            checkTrueFct: checkTrueFct,
            timeoutFct: hobs.actions.jQSelectorPollCheckTestStepTimeoutFct.bind(this),
            demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY
        });

        hobs.teststeps.jQSelectorPollCheckTestStep.call(this, null, null, selector, _options);
    };

    hobs.utils.definePrototype(
        core.simulate,
        hobs.teststeps.jQSelectorPollCheckTestStep,
        {
            'type' : core.namespace + ".simulate",
            'res-msg-passed' : 'Simulated ${event:1} on ${element:0} with ${options:2}',
            'res-msg-failed' : 'Simulate of ${event:1} on ${element:0} with ${options:2} failed'
        }
    );



})(window.hobs, window.hobs.actions.core, $);


;

(function(hobs, core, $) {
    "use strict";



    /**
     * @class
     *
     * Executes custom Js code
     *
     * @memberof hobs.actions.core
     *
     * @augments hobs.TestStep
     *
     * @param {function} fct The function that will be executed in a try catch block
     * @param {boolean} [expectThrow=false] Control whether the function is expected to throw an exception or not
     * @param {TestStepOptions} [options] Test method options (Accepts: "delay")
     */
    hobs.actions.core.tryCatch = function(tryFct, expectThrow, options) {
        var _action = this;
        _action.fct = tryFct;
        _action.expectThrow = $.isFunction(expectThrow) ? expectThrow : (expectThrow === true ? true : false);
        _action.thrown = null;

        var syncFct = function(opts) {
            var callingstep = this,
                res = null,
                // Process dynamic parameters
                fct_dyn = hobs.handleDynParameters(_action.fct, opts),
                expectThrow_dyn = hobs.handleDynParameters(_action.expectThrow, opts) === true ? true : false;

            _action.expectThrow = expectThrow_dyn;

            // Handle Demo Mode
            hobs.actions.handleDemoMode.call(_action, opts, null, 'blue', 'Trying Javascript code block', {type: 'CENTER_BOX'});

            var done = function (r) {
                r = r || hobs.Chaining.Step.STATE_PASSED;

                function timeoutHandler() {
                    _action.execData('args', [fct_dyn, expectThrow_dyn, options]);
                    callingstep.done(r);
                }

                setTimeout(timeoutHandler, 50);
            };

            try {
                // TODO implement error handling & timeout for async
                if (fct_dyn.length > 1) {
                    fct_dyn(opts, done);
                } else {
                    fct_dyn(opts);

                    res = expectThrow_dyn ? hobs.Chaining.Step.STATE_FAILED : hobs.Chaining.Step.STATE_PASSED;
                    done(res);
                }
            }
            catch (e) {
                _action.thrown = e.stack;

                res = expectThrow_dyn ? hobs.Chaining.Step.STATE_PASSED : hobs.Chaining.Step.STATE_FAILED;
                _action.execData('args', [fct_dyn, expectThrow_dyn, (options || null), e.stack]);
                callingstep.done(res,
                    {
                        msg: 'Execution of ${function:0} threw ${exception:3}'
                    }
                );
            }
        },

        _options = $.extend({}, options, {demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY}),

        step = new hobs.Chaining.Step(syncFct, options);

        hobs.TestStep.call(this, null, null, step, _options);
    };

    hobs.utils.definePrototype(
        core.tryCatch,
        hobs.TestStep,
        {
            'type' : core.namespace + ".tryCatch",
            'res-msg-passed' : 'Execution of ${function:0} did not throw any exception'
        }
    );



})(window.hobs, window.hobs.actions.core, $);


;

(function(hobs, core, $) {
    "use strict";



    /**
     * @class
     *
     * Simulates text typing on an input type DOM element (using "input" type events)
     *
     * @memberof hobs.actions.core
     *
     * @augments hobs.teststeps.jQSelectorPollCheckTestStep
     *
     * @param {String} selector jQuery selector for the DOM Element
     * @param {String} [text=""] The text to fill the input with
     * @param {TestActionOptions} [options] Test method options
     */
    hobs.actions.core.typeInput = function(selector, text, options) {
        var _action = this;

        // _action.selector = selector;
        _action.text = text;

        var checkTrueFct = function(opts) {
            // Process dynamic parameters
            var // selector_dyn = hobs.handleDynParameters(_action.selector, opts),
                text_dyn = hobs.handleDynParameters(_action.text, opts);

            _action.execData('args', [_action.execData('args')[0], text_dyn, options]);

            // Handle Demo Mode
            hobs.actions.handleDemoMode.call(_action, opts, _action.execData('args')[0], 'blue', 'Type "' + text_dyn + '" in input');

            var $el = _action.execData('element');

            $el.focus();

            var chars = text_dyn.split('');
            for (var i=0; i < chars.length; i++) {
                $el.val($el.val()+chars[i]);
                var evt = hobs.context().document.createEvent('CustomEvent');
                evt.initCustomEvent('input', true, true, {bubbles: true, cancelable: true});
                $el[0].dispatchEvent(evt);
            }

            this.done(hobs.Chaining.Step.STATE_PASSED);
        },

        _options = $.extend({}, options, {
            checkTrueFct: checkTrueFct,
            timeoutFct: hobs.actions.jQSelectorPollCheckTestStepTimeoutFct.bind(this),
            demoModeDelay: hobs.actions.DEMO_MODE_DEFAULT_DELAY
        });

        hobs.teststeps.jQSelectorPollCheckTestStep.call(this, null, null, selector, _options);
    };

    hobs.utils.definePrototype(
        core.typeInput,
        hobs.teststeps.jQSelectorPollCheckTestStep,
        {
            'type' : core.namespace + ".typeInput",
            'res-msg-passed' : 'Typed ${text:1} in ${element:0}',
            'res-msg-failed' : 'Type of ${text:1} in ${element:0} failed'
        }
    );



})(window.hobs, window.hobs.actions.core, $);


;

(function(hobs, core, $) {
    "use strict";



    /**
     * @class
     *
     * @desc Waits N ms. before continuing the test
     *
     * @memberof hobs.actions.core
     *
     * @augments hobs.TestStep
     *
     * @param {Number} [ms=2500] Waiting time in ms.
     * @param {TestStepOptions} [options] Option object to control action execution
     */
    hobs.actions.core.wait = function(ms, options) {
        var _action = this;

        _action.ms = ms;

        var stepFct = function(opts) {
            var callingStep = this;
            // Process dynamic parameters
            var ms_dyn = hobs.handleDynParameters(_action.ms, opts);

            // In case processed parameter is not a number, force it to 2500
            ms_dyn = $.isNumeric(ms_dyn) ? ms_dyn : 2500;

            _action.execData('args', [ms_dyn, options]);
            // Handle Demo Mode
            hobs.actions.handleDemoMode.call(_action, opts, null, 'blue', 'Wait for ' + ms_dyn + 'ms.', {type: 'CENTER_BOX'});

            function timeoutHandler() {
                callingStep.done(hobs.Chaining.Step.STATE_PASSED);
            }

            setTimeout(timeoutHandler, ms_dyn);
        },

            step = new hobs.Chaining.Step(stepFct),

            _options = $.extend({}, options, {demoModeDelay: 0});

        hobs.TestStep.call(this, null, null, step, _options);
    };

    hobs.utils.definePrototype(
        core.wait,
        hobs.TestStep,
        {
            'type' : core.namespace + ".wait",
            'res-msg-passed' : 'Waited ${0} ms.'
        }
    );

})(window.hobs, window.hobs.actions.core, $);


;

(function(hobs, core, $) {
    "use strict";



    /**
     * @class
     *
     * @desc Execute a Generator function
     *
     * @memberof hobs.actions.core
     *
     * @augments hobs.TestStep
     *
     * @param {function} generatorFn The generator function
     * @param {TestStepOptions} [options] Option object to control action execution
     */
    hobs.actions.core.yieldThis = function(genFn, options) {
        var _action = this;

        _action.execData('genRes', []);

        _action.genFn = genFn;

        var stepFct = function(opts) {
            var callingStep = this;
            // Process dynamic parameters
            var genFn_dyn = hobs.handleDynParameters(_action.genFn, opts);

            _action.execData('args', [genFn_dyn, options]);

            // // Handle Demo Mode
            // hobs.actions.handleDemoMode.call(_action, opts, null, 'blue', 'Wait for ' + ms_dyn + 'ms.', {type: 'CENTER_BOX'});

            spawn.call(_action, genFn_dyn, opts).then(function(err) {
                _action.computeResult();
                callingStep.done(_action.state());
            });
        },

        step = new hobs.Chaining.Step(stepFct),

        _options = $.extend({}, options);

        hobs.TestStep.call(this, null, null, step, _options);

        _action.execData('genRes', []);
    };

    hobs.utils.definePrototype(
        core.yieldThis,
        hobs.TestStep,
        {
            'type' : core.namespace + ".yieldThis",
            'res-msg-passed' : 'Executed generator ${function:0}',
            'res-msg-failed' : 'Execution of generator ${function:0} failed'
        }
    );


    /**
     * @returns {object} Returns an Object representing the result of the test step execution
     * @override
     **/
    hobs.actions.core.yieldThis.prototype.result = function(format, withDetails) {
        if (format) {
            return hobs.reporters.format(this, format, withDetails);
        }

        if (this._result) {
            return this._result;
        }
        else {
            return this.computeResult();
        }
    };

    hobs.actions.core.yieldThis.prototype.computeResult = function () {
        var genRes = this.execData('genRes'),
            steps = [],
            hasPassed = true;

        for (var i=0; i < genRes.length; i++) {
            var step = genRes[i];
            if ($.isFunction(step.result)) {
                var sRes = step.result();
                if(!sRes.passed) {
                    hasPassed = false;
                }
                steps.push(sRes);
            }
        }

        this._state = hasPassed ? hobs.Chaining.Step.STATE_PASSED : hobs.Chaining.Step.STATE_FAILED;

        var res = hobs.TestStep.prototype.result.call(this);
        res.steps = steps;

        this._result = res;

        return res;
    };

    function spawn(generatorFunc, options) {
        var _action = this;
        var _execOptions = options;
        _action.execData('genRes', []);

        function continuer(verb) {
            var result;
            try {
                result = generator[verb]();
            } catch (err) {
                return Promise.reject(err);
            }

            if (result.done) {
                return result.value;
            } else {
                return result.value.exec(_execOptions)
                            .always(function() {
                                // this === hobs action object
                                _action.execData('genRes').push(this);
                            }.bind(result.value))
                            .then(onFulfilled, onRejected);
            }
        }
        var generator = generatorFunc();
        var onFulfilled = continuer.bind(continuer, "next");
        var onRejected = continuer.bind(continuer, "throw");
        return onFulfilled();
    }

})(window.hobs, window.hobs.actions.core, $);


;

(function(window, hobs, $) {
    "use strict";



    /**
     * @namespace
     *
     * @desc Result formating utils
     *
     * @property {string} TXT Human readable text format
     * @property {string} HTML HTML format
     * @property {string} JUNIT_XML XML format following {@link https://svn.jenkins-ci.org/trunk/hudson/dtkit/dtkit-format/dtkit-junit-model/src/main/resources/com/thalesgroup/dtkit/junit/model/xsd/junit-4.xsd}. 
     *                              You can use this format to get test result report in Jenkins CI.
     *
     * @memberof hobs
     **/
    hobs.reporters = {};



    hobs.reporters.parseArgValue = function(argument) {
        if (argument === undefined || argument === null) {
            return "[null]";
        }
        else if (argument instanceof $) {
            return 'jQuery element with selector "' + argument.selector + '"';
        }
        else if ($.type(argument) === 'string') {
            return argument;
        }
        else if ($.type(argument) === 'object') {
            if (argument.hasOwnProperty('name')) {
                return argument.name;
            }
            else {
                return JSON.stringify(argument, null, '\t');
            }
        }
        else if ($.type(argument) === 'function') {
            return argument.toString();
        }
        else {
            return argument.toString();
        }
    };

    /**
     * Processes Hobbes.js result objects into different formats
     *
     * @param {object} result An Hobbes.js result object (see {@link hobs.TestSuite}, {@link hobs.TestCase})
     * @param {hobs.utils.resultOutput} format The format of the output {@link hobs.utils.resultOutput}
     *
     * @returns {string} A String representation the test element result in the chosen format
     *
     *
     *
     * @example <caption>Get formatted report of TestCase execution</caption>
     * var tc = new hobs.TestCase('tc')
     *                      .navigateTo('sample-iframe.html')
     *                      .click('button')
     *                      .asserts.exists('#b1');
     *
     * var tcRes = null;
     *
     * // Asynchronous execution of the TestCase
     * tc.exec().then(function() {
     *      tcRes = tc.result();
     * });
     *
     * // Wait until the test case got executed, then
     *
     * // TXT report
     * hobs.reporters.formatResult(tcRes, hobs.reporters.TXT);
     * // [TC] tc (duration: 0.182s.)
     * //   1 [V] navigateTo : URL[sample-iframe.html]
     * //   2 [V] click : clicked ELEMENT[button]
     * //   3 [V] asserts exists : assert ELEMENT[#b1] does [] exist in the DOM
     *
     * // HTML report
     * hobs.reporters.formatResult(tcRes, hobs.reporters.HTML);
     *
     * // JUNIT XML report
     * hobs.reporters.formatResult(tcRes, hobs.reporters.JUNIT_XML);
     **/
    hobs.reporters.formatResult = function(result, format, withDetails) {
        return format.call(this, result, withDetails);
    };

    hobs.reporters.format = function(testElement, format, withDetails) {
        if (!(testElement instanceof hobs.TestStep)) {
            throw new Error('hobs.reporters.format only accepts Hobbes.js test elements (hobs.TestSuite, hobs.TestCase, ...)');
        }

        return format.call(this, testElement.result(), withDetails);
    };



})(window, window.hobs, $);


;

// Javascript script template
// <script type="text/javascript">
//     function toggle_vis() {
//         var list = this.nextSibling;
//         list.style.display = list.style.display === 'none' ? '':'none';
//     }
//
//     var lists = document.getElementsByTagName('h1');
//
//     for (var i=0; i < lists.length; i++) {
//         var l = lists[i];
//         l.onclick = toggle_vis;
//     }
//
//     var lists = document.getElementsByTagName('h3');
//
//     for (var i=0; i < lists.length; i++) {
//         var l = lists[i];
//         l.onclick = toggle_vis;
//     }
// </script>


(function(window, hobs, $) {
    "use strict";


    var htmlResultTemplate = '<html><head><meta charset="utf-8" /><style>body{font-size: 1rem; font-family: monospace;}h1,h3{cursor:pointer;}ol.steps li{list-style:inherit;}li{list-style: none;}.param{color: blue;}pre.multiline,.tc-steps{position: relative; left: 2.5rem;}.skipped{color: gray;}.passed{color: green;}.failed{color: red;}.phase-block{padding-left:2rem;border-left:2px solid #e6f7ff;}.sep-before{margin-bottom:3rem;}.sep-after{margin-top:3rem;}.phase-icon{position:relative;float:left;margin-top:0px;left:-1.8rem;} a{text-decoration:none;}</style></head><body>%TEST_RESULT% <script type="text/javascript">function toggle_vis(){var list=this.nextSibling;list.style.display=list.style.display===\'none\'?\'\':\'none\'}var lists=document.getElementsByTagName(\'h1\');for(var i=0;i<lists.length;i++){var l=lists[i];l.onclick=toggle_vis}var lists=document.getElementsByTagName(\'h3\');for(var i=0;i<lists.length;i++){var l=lists[i];l.onclick=toggle_vis}</script></body></html>';



    hobs.reporters.HTML = function(result, withDetails) {
        var $root = $('<html />'),
            $result = $(result),
            $testsuites = $('<div class="testsuites" />');

        $result.each(function(idx, res) {
            formatElement(res, $testsuites, withDetails, true);
        });

        $root.append($testsuites);

        hobs.log("HTML formatted result:");
        hobs.log($root.html());

        return htmlResultTemplate.replace("%TEST_RESULT%", $root.html());
    };



    function formatElement(res, $root, withDetails, isTopLevel) {

        var $testsuite = $('<' + 'div' + ' />'),
            $testcases = $('<ul style="display:none;" class="testelement-steps" />'),
            tcFailures = 0,
            durationInSec = (res.duration/1000).toString(),
            headingLevel = (isTopLevel ? 'h1' : 'h3'),
            $testElement = $('<' + headingLevel + ' />'),
            stepRetryCount = res.retryCount > 0 ? ' (&#9888; #retries: ' + res.retryCount + ')' : '',
            $stepExecPhase = $('<div class="phase-icon param" />');

        if (res.phase) {
            if (res.phase === 'before') {
                $stepExecPhase.html('&#x02923');
                $testsuite.addClass('sep-before');
            }
            else {
                $stepExecPhase.html('&#x02925');
                $testsuite.addClass('sep-after');
            }

            $testsuite.addClass('phase-block');

            $testsuite.append($stepExecPhase);
        }

        var msg = '';

        if (res.report
            && res.report.params
            && res.report.msg)
        {
            var re = /\$\{([\w\s]+[:]*\d*)\}/g,
                m = null,
                actMsg = res.report.msg,
                parsedMsg = actMsg,
                args = res.report.params;

            while ((m = re.exec(actMsg)) !== null) {
                if (m.index === re.lastIndex) {
                    re.lastIndex++;
                }

                if (m[1].indexOf(":") >= 0) {
                    var tooltipMsg = m[1].split(":"),
                        tmpMsg = hobs.reporters.parseArgValue(args[parseInt(tooltipMsg[1])]);

                    if (tmpMsg.indexOf("\n") >= 0) {
                        tmpMsg = '<pre class="multiline param">' + tmpMsg + "</pre>";
                    }

                    parsedMsg = parsedMsg.replace(m[0], tooltipMsg[0].toUpperCase() + '[<span class="param">' + tmpMsg + '</span>]');
                }
                else {
                    parsedMsg = parsedMsg.replace(m[0], '[<span class="param">' + hobs.reporters.parseArgValue(args[parseInt(m[1])]) + '</span>]');
                }

            }

            msg += parsedMsg;
        }
        else if (res.state === 'stopped') {
            msg += res.type;
        }
        else {
            msg += res.msg;
        }

        var stepStatusIcon = (res.state === 'stopped' ? '<span class="skipped">&bull;</span>' : (res.passed ? '<span class="passed">&#10003;</span>' : '<span class="failed">&#10007;</span>'));
        var screenshotIcon = (res.metadata !== undefined && res.metadata.screenshot !==  undefined) ? '<a href="'+res.metadata.screenshot+'" target="_blank">&#128247;</a> ':'';

        $testElement.html(stepStatusIcon + ' ' + screenshotIcon + msg + stepRetryCount + ' (&#128336; ' + durationInSec +'s.)').appendTo($testsuite);

        if(!res.passed) {
            $testcases.css('display', '');
        }

        $testcases.appendTo($testsuite);

        $testsuite.attr("id", res.id);
        $testsuite.attr("name", res.name);
        $testsuite.attr("time", durationInSec);
        $testsuite.attr("failures", tcFailures);
        $testsuite.attr("errors", tcFailures);

        if (res.steps) {
            $testsuite.attr("tests", res.steps.length);
        }

        if ((withDetails || res.state === 'failed') && res.steps && res.steps.length > 0) {
            $(res.steps).each(function(index, stepRes) {
                formatElement.call(this, stepRes, $testcases, withDetails, false);
            });
        }

        $testsuite.appendTo($root);
    }


})(window, window.hobs, $);


;

(function(window, hobs, $) {
    "use strict";



    hobs.reporters.JUNIT_XML = function(result, withDetails) {

        var $root = $('<root />'),
            $testsuites = $('<testsuites />'),
            $result = $(result),
            xmlTagMap = {};

        function getXMLFriendly(unsafe) {
            return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/'/g, "&apos;")
            .replace(/"/g, "&quot;");
        }

        xmlTagMap[hobs.TestSuite.prototype.type] = {
            tag: "testsuite",
            handler: function(res, objMap, $target, withDetails2) {
                var $testsuite = $('<' + objMap.tag + ' />'),
                    // Init counters for
                    tcCounter = 0,
                    tcFailures = 0,
                    durationInSec = 0;

                $(res.steps).each(function(idx, step) {
                    if (step.type === hobs.TestSuite.prototype.type) {
                        step.name = [res.name, " > ", step.name].join("");
                    }

                    if (step.type && !step.phase) {
                        var $tcTag = xmlTagMap[step.type].handler.call(res, step, xmlTagMap[step.type], $target, withDetails2);

                        if (step.type === hobs.TestCase.prototype.type) {
                            tcCounter++;
                            durationInSec += step.duration;

                            if ($tcTag.find("failure").length > 0) {
                                tcFailures++;
                            }

                            $testsuite.append($tcTag);
                        }
                    }
                });

                $testsuite.attr("id", res.id);
                $testsuite.attr("name", getXMLFriendly(res.name));
                $testsuite.attr("tests", tcCounter);
                $testsuite.attr("time", (durationInSec/1000).toString());

                $testsuite.attr("failures", tcFailures);
                $testsuite.attr("errors", tcFailures);

                if ($testsuite.find("testcase").length > 0) {
                    $target.append($testsuite);
                }

                return $testsuite;
            }
        };

        xmlTagMap[hobs.TestCase.prototype.type] = {
            tag: "testcase",
            handler: function(res, objMap, target, withDetails3) {
                // this === parent TestSuite

                var $tcTag = $('<' + objMap.tag + ' />'),
                    durationInSec = (res.duration/1000).toString();

                // Test Failed!
                // Request TXT output of the test case and append it in a <failure /> section
                if (!res.passed || withDetails3) {
                    var $detailsTag = (res.passed ? $('<system-out />') : $('<failure type="Failure" />'));

                    $detailsTag.append(getXMLFriendly(hobs.reporters.formatResult(res, hobs.reporters.TXT, true)));
                    $tcTag.append($detailsTag);
                }

                var phase = res.phase ? '[' + res.phase + '] ' : '';

                if (res.retryCount > 0) {
                    $tcTag.attr("retries", res.retryCount);
                }

                $tcTag.attr("name", getXMLFriendly(phase + res.name));
                $tcTag.attr("time", durationInSec);

                return $tcTag;
            }
        };

        if (hobs.TestCase.prototype.type === result.type) {
            // testcase only
            var $singleTag = xmlTagMap[result.type].handler.call(this, result, xmlTagMap[result.type], $testsuites, withDetails);

            $root.append($singleTag[0]);
        } else {
            // default testsuite containing testsuite or testcase
            $result.each(function(idx, res) {
                if (res.type) {
                    var objMap = xmlTagMap[res.type];

                    objMap.handler.call(this, res, objMap, $testsuites, withDetails);
                }
            });

            $root.append($testsuites);
        }

        var xmlOutput = $root.html().replace(/&/g,'&#x26;');

        hobs.log("jUnit XML formatted result:");
        hobs.log(xmlOutput);

        return xmlOutput;
    };



})(window, window.hobs, $);


;

(function(window, hobs, $) {
    "use strict";



    var TXT_INDENT_PREFIX = '    ';

    var GENERIC_TXT = function(res, withDetails, prefix) {

        //level = (level ? level : 0);

        prefix = (prefix ? prefix : '');

        var //prefix = '',
            phase = '';

        if (res.phase) {
            phase = '[' + res.phase + '] ';
        }

        // for (var i = 0; i < level; i++) {
        //     prefix = '  ' + prefix;
        // }

        var newPrefix = res.phase ? (res.phase === 'before' ? prefix.replace(new RegExp('    $'), ' << ') : prefix.replace(new RegExp('    $'), ' >> ')) :
            prefix;

        var prefMsg = newPrefix + '[' + (res.state === 'stopped' ? '-' : (res.passed ? "V":"X")) + '] ' + phase,
            stepDurationInSec = res.duration ? ' (duration: ' + (res.duration/1000).toString() + 's.)' : '',
            stepRetryCount = res.retryCount > 0 ? ' (#retries: ' + res.retryCount + ')' : '';


        if (res.state === 'stopped') {
            prefMsg += res.type;
        }
        else if (res.report
            && res.report.params
            && res.report.msg)
        {
            var re = /\$\{([\w\s]+[:]*\d*)\}/g,
                m = null,
                actMsg = res.report.msg,
                parsedMsg = actMsg,
                args = res.report.params;

            while ((m = re.exec(actMsg)) !== null) {
                if (m.index === re.lastIndex) {
                    re.lastIndex++;
                }

                if (m[1].indexOf(":") >= 0) {
                    var tooltipMsg = m[1].split(":");
                    parsedMsg = parsedMsg.replace(m[0], tooltipMsg[0].toUpperCase() + '[' + hobs.reporters.parseArgValue(args[parseInt(tooltipMsg[1])]) + ']');
                }
                else {
                    parsedMsg = parsedMsg.replace(m[0], '[' + hobs.reporters.parseArgValue(args[parseInt(m[1])]) + ']');
                }

            }

            prefMsg += parsedMsg + stepDurationInSec + stepRetryCount;
        }
        else {
            prefMsg += res.msg + stepDurationInSec + stepRetryCount;
        }

        if (res.state === 'failed') {
            prefMsg += ' (' + res.type + ')';
        }

        var msg = [prefMsg];

        if ((withDetails || res.state === 'failed') && res.steps && res.steps.length > 0) {
            $(res.steps).each(function(index, stepRes) {
                msg = msg.concat(GENERIC_TXT.call(this, stepRes, withDetails, (prefix + TXT_INDENT_PREFIX)));
            });
        }

        if (phase !== '') {
            if (phase === '[before] ') {
                msg = [].concat('', msg);
            }
            if (phase === '[after] ') {
                msg = [].concat(msg, ' ');
            }
        }

        return msg.join("\n");

    };

    hobs.reporters.TXT = function(result, withDetails, prefix) {
        var $result = $(result),
            formatedRes = '';

        $result.each(function(idx, res) {
            formatedRes += GENERIC_TXT.call(this, res, withDetails);
        });

        return formatedRes;
    };



})(window, window.hobs, $);


;

(function(hobs, jsyaml, $) {
    "use strict";

    hobs.jsyaml = {};

    function join() {
        return arguments[0].join('');
    }

    var joinYamlType = new jsyaml.Type('!join', {
        kind: 'sequence',

        // Loader must check if the input object is suitable for this type.
        resolve: function (data) {
            // `data` may be either:
            // - Null in case of an "empty node" (http://www.yaml.org/spec/1.2/spec.html#id2786563)
            // - Array since we specified `kind` to 'sequence'
            return data !== null && data.length > 1;
        },

        // If a node is resolved, use it to create a Point instance.
        construct: function (data) {
            return join(data);
        }

        // Dumper must represent Point objects as three-element sequence in YAML.
        // represent
    });

    hobs.jsyaml.HOBBES_SCHEMA = jsyaml.Schema.create([ joinYamlType ]);

})(window.hobs, window.jsyaml, $);


;

(function(hobs, jsyaml, $) {
    "use strict";



    /**
     * @ignore
     **/
    hobs.structure = {};
    hobs.structure.current = null;
    hobs.structure.currentPage = null;

    hobs.utils.structure = {};

    hobs.utils.structure.formats = {};
    hobs.utils.structure.formats.YAML = "yaml";

    hobs.utils.structure.processors = {};
    hobs.utils.structure.processors[hobs.utils.structure.formats.YAML] = function(data) {
        return jsyaml.load(data, {schema: hobs.jsyaml.HOBBES_SCHEMA});
    };

    hobs.utils.loadWebStructure = function(path, format, cb) {
        format = format || hobs.utils.structure.formats.YAML;

        $.get(path, function(res) {
            var processedData = hobs.utils.structure.processors[format](res);
            hobs.structure.current = processedData;

            if (cb !== null && cb !== undefined) {
                cb(processedData);
            }
        });
    };



    // WIP Element path implementation
    hobs.utils.PATH_SEPERATOR = ">";

    hobs.utils.getElementFromPath = function(path, elementKey, obj, opts) {
        var paths = hobs.utils.getStepsFromPath(path),
            segment = paths.shift(),
            searchObj = obj,
            options = opts || {},
            selector = "";

        while (segment !== undefined && segment !== null) {
            var foundSegmentSelector = hobs.utils.deepKeySearchInObject(searchObj, segment);

            searchObj = foundSegmentSelector[segment];

            if (searchObj.hasOwnProperty(elementKey)) {
                if (selector !== "") {
                    selector += " ";
                }
                selector = selector + searchObj[elementKey];
            }

            segment = paths.shift();
        }

        if (options.hasOwnProperty("prefix")) {
            selector = options.prefix + selector;
        }

        if (options.hasOwnProperty("suffix")) {
            selector += options.suffix;
        }

        return selector;
    };

    hobs.utils.getSelectorFromPath = function(path, obj, options) {
        return hobs.utils.getElementFromPath(path, "selector", obj, options);
    };

    hobs.utils.getStepsFromPath = function(path, separator) {
        separator = separator || hobs.utils.PATH_SEPERATOR;

        var steps = [],
            pattern = "\\s*" + separator + "\\s*",
            re = new RegExp(pattern, "g");

        steps = path.split(re);

        return steps;
    };



})(window.hobs, window.jsyaml, $);


;

(function(hobs, $) {

    /**
     * WEBELEMENT - hobs.WebElement
     * @ignore
     **/
    /* jshint strict: false */
    hobs.WebElement = function (name, selector, parent) {
        this._name = name;
        this._id = hobs.utils.getIdFromString(name);
        this._parent = parent;
        this.selector = selector;
        this._children = [];
        this._data = {};

        return this;
    };

    hobs.WebElement.prototype = {
        get selector() {
            var pSelector = (this._parent && this._parent.selector) ? this._parent.selector + ' ' : '';
            return pSelector + this._selector;
        },
        set selector(selector) {
            this._selector = selector; //pSelector + selector;
        },

        get parent() {
            return this._parent;
        },
        set parent(parent) {
            this._parent = parent;
        },

        get name() {
            return this._name;
        }
    };

    hobs.WebElement.prototype.data = function(key, value) {
        if (key === undefined && value === undefined) {
            return this._data;
        }
        else if (key !== undefined && key !== null && value === undefined) {
            return this._data[key];
        }
        else {
            this._data[key] = value;

            return this;
        }
    };

    hobs.WebElement.prototype.addChild = function(webelement) {
        webelement.parent = this;
        this._children.push(webelement);

        return this;
    };

    hobs.WebElement.prototype.getChild = function(pattern) {
        if (jQuery.isNumeric(pattern)) {
            return this._children[pattern];
        }
        else if (typeof pattern === 'string') {
            return hobs.utils.objectFindByKey(this._children, '_name', pattern);
        }

        return null;
    };

    hobs.WebElement.prototype.c = hobs.WebElement.prototype.getChild;

    // hobs.fKey = function(obj, keyObj) {
    //     var p, key, val, tRet;
    //     for (p in keyObj) {
    //         if (keyObj.hasOwnProperty(p)) {
    //             key = p;
    //             val = keyObj[p];
    //         }
    //     }
    //
    //     for (p in obj) {
    //         if (p === key) {
    //             if (obj[p] === val) {
    //                 return obj;
    //             }
    //         } else if (obj[p] instanceof Object) {
    //             if (obj.hasOwnProperty(p)) {
    //                 tRet = hobs.fKey(obj[p], keyObj);
    //                 if (tRet) { return tRet; }
    //             }
    //         }
    //     }
    //
    //     return false;
    // };

}(window.hobs, $));


;

(function(hobs, $) {
    "use strict";

    hobs.webelements = {};

    /**
     * PAGE - hobs.webelements.Page <= hobs.WebElement
     **/
    hobs.webelements.Page = function(name, url, title) {
        var defaultPageSelector = 'body';
        this._url = url;
        this._title = title;

        hobs.WebElement.call(this, name, defaultPageSelector, null);
    };

    hobs.webelements.Page.prototype = new hobs.WebElement();

    Object.defineProperty(hobs.webelements.Page.prototype, 'url', {
        get: function() {
            return this._url;
        }
    });

    /*
    hobs.WebElement.Page.prototype = {
        get title() {
            return this._title;
        },

        get url() {
            return this._url;
        }
    };
    */

    // hobs.webelements.AEM = function(version) {
    //     var name = "AEM";
    //
    //     this._version = version;
    //
    //     hobs.WebElement.call(this, name, null, null);
    // };
    //
    // hobs.webelements.AEM.prototype = new hobs.WebElement();

}(window.hobs, $));


;

(function (window, hobs, $) {
    "use strict";

    function fctHandler() {
        var fctArgs = Array.prototype.slice.call(arguments),
            k = null,
            args = [];

        for (k in fctArgs) {
            if (k > 1) {
                args.push(fctArgs[k]);
            }
        }

        var src = fctArgs[0];
        var key = fctArgs[1];

        var testAction = new src[key]();

        src[key].apply(testAction, args);

        return testAction;
    }

    function fctExecHandler() {
        var fctArgs = Array.prototype.slice.call(arguments),
            k = null,
            args = [];

        for (k in fctArgs) {
            if (k > 1) {
                args.push(fctArgs[k]);
            }
        }

        var src = fctArgs[0];
        var key = fctArgs[1];

        var testAction = new src[key]();

        src[key].apply(testAction, args);

        if (hobs.TestCase.prototype.isPrototypeOf(this)) {
            this.testcaseChain.addStep(testAction);
        }

        return testAction;
    }

    hobs.exportTo = function(ctx) {
        ctx = ctx || this;

        // Export TestSuite, TestCase
        var cl = null,
            classes = [
                {src: hobs.TestSuite.prototype, key: 'add'},
                {src: hobs, key: 'TestSuite'},
                {src: hobs, key: 'TestCase'}
            ];

        for (var i=0; i < classes.length; i++ ) {
            cl = classes[i];
            window[cl.key] = $.proxy(fctHandler, ctx, cl.src, cl.key);
        }

        // Export Core actions
        var coreActions = hobs.actions.core;
        var key, key2;

        for (key in coreActions) {
            if (key !== 'if') {
                window[key] = $.proxy(fctExecHandler, ctx, coreActions, key);
            }
        }

        window.assert = {};

        // Export Assertions
        var assAct = hobs.actions.assert;

        for (key2 in assAct) {
            window.assert[key2] = $.proxy(fctExecHandler, ctx, assAct, key2);
        }
    };

    hobs.exportTo();

})(window, window.hobs, $);
